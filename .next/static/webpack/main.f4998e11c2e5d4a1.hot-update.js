"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar _s3 = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initNext = initNext;\nexports.render = render;\nexports.renderError = renderError;\nexports.emitter = exports.router = exports.version = void 0;\n__webpack_require__(/*! @next/polyfill-module */ \"./node_modules/@next/polyfill-module/dist/polyfill-module.js\");\nvar _react = _interopRequireDefault1(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _reactDom = _interopRequireDefault1(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nvar _styledJsx = __webpack_require__(/*! styled-jsx */ \"./node_modules/styled-jsx/index.js\");\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interopRequireDefault1(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interopRequireDefault1(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interopRequireDefault1(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _vitals = __webpack_require__(/*! ./vitals */ \"./node_modules/next/dist/client/vitals.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard1(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _objectSpread(target) {\n    var _arguments = arguments, _loop = function(i) {\n        var source = _arguments[i] != null ? _arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    };\n    for(var i = 1; i < arguments.length; i++)_loop(i);\n    return target;\n}\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar version = \"12.0.2\";\nexports.version = version;\nvar looseToArray = function(input) {\n    return [].slice.call(input);\n};\nvar hydrateProps = data.props, hydrateErr = data.err, page = data.page, query = data.query, buildId = data.buildId, assetPrefix = data.assetPrefix, runtimeConfig = data.runtimeConfig, dynamicIds = data.dynamicIds, isFallback = data.isFallback, locale = data.locale, locales = data.locales, domainLocales = data.domainLocales, isPreview = data.isPreview, rsc = data.rsc;\nvar defaultLocale = data.defaultLocale;\nvar prefix = assetPrefix || '';\n// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n// So, this is how we do it in the client side at runtime\n__webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n;\n// Initialize next/config with the environment configuration\n(0, _runtimeConfig).setConfig({\n    serverRuntimeConfig: {\n    },\n    publicRuntimeConfig: runtimeConfig || {\n    }\n});\nvar asPath = (0, _utils).getURL();\n// make sure not to attempt stripping basePath for 404s\nif ((0, _router).hasBasePath(asPath)) {\n    asPath = (0, _router).delBasePath(asPath);\n}\nif (false) { var detectedDomain, localePathResult, parsedAs, formatUrl, parseRelativeUrl, detectDomainLocale, normalizeLocalePath; }\nif (data.scriptLoader) {\n    var initScriptLoader = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\").initScriptLoader;\n    initScriptLoader(data.scriptLoader);\n}\nvar pageLoader = new _pageLoader.default(buildId, prefix);\nvar register = function(param) {\n    var _param = _slicedToArray(param, 2), r = _param[0], f = _param[1];\n    return pageLoader.routeLoader.onEntrypoint(r, f);\n};\nif (window.__NEXT_P) {\n    // Defer page registration for another tick. This will increase the overall\n    // latency in hydrating the page, but reduce the total blocking time.\n    window.__NEXT_P.map(function(p) {\n        return setTimeout(function() {\n            return register(p);\n        }, 0);\n    });\n}\nwindow.__NEXT_P = [];\nwindow.__NEXT_P.push = register;\nvar headManager = (0, _headManager).default();\nvar appElement = document.getElementById('__next');\nvar lastRenderReject;\nvar webpackHMR;\nvar router;\nexports.router = router;\nvar CachedApp, onPerfEntry;\nheadManager.getIsSsr = function() {\n    return router.isSsr;\n};\nvar Container = /*#__PURE__*/ function(_Component) {\n    _inherits(Container, _Component);\n    function Container() {\n        _classCallCheck(this, Container);\n        return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));\n    }\n    _createClass(Container, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(componentErr, info) {\n                this.props.fn(componentErr, info);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.scrollToHash();\n                // We need to replace the router state if:\n                // - the page was (auto) exported and has a query string or search (hash)\n                // - it was auto exported and is a dynamic route (to provide params)\n                // - if it is a client-side skeleton (fallback render)\n                if (router.isSsr && // the asPath unexpectedly e.g. adding basePath when\n                // it wasn't originally present\n                page !== '/404' && page !== '/_error' && (isFallback || data.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false) || hydrateProps && hydrateProps.__N_SSG && (location.search || false))) {\n                    // update query on mount for exported pages\n                    router.replace(router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                        // @ts-ignore\n                        // WARNING: `_h` is an internal option for handing Next.js\n                        // client-side hydration. Your app should _never_ use this property.\n                        // It may change at any time without notice.\n                        _h: 1,\n                        // Fallback pages must trigger the data fetch, so the transition is\n                        // not shallow.\n                        // Other pages (strictly updating query) happens shallowly, as data\n                        // requirements would already be present.\n                        shallow: !isFallback\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.scrollToHash();\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash() {\n                var hash = location.hash;\n                hash = hash && hash.substring(1);\n                if (!hash) return;\n                var el = document.getElementById(hash);\n                if (!el) return;\n                // If we call scrollIntoView() in here without a setTimeout\n                // it won't scroll properly.\n                setTimeout(function() {\n                    return el.scrollIntoView();\n                }, 0);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (false) {} else {\n                    var ReactDevOverlay = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").ReactDevOverlay;\n                    return(/*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children));\n                }\n            }\n        }\n    ]);\n    return Container;\n}(_react.default.Component);\nvar emitter = (0, _mitt).default();\nexports.emitter = emitter;\nvar CachedComponent;\nfunction _initNext() {\n    _initNext = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(param1) {\n        var opts = param1 === void 0 ? {\n        } : param1;\n        var initialErr, appEntrypoint, app, mod, exportedReportWebVitals, pageEntrypoint, isValidElementType, getNodeError, renderCtx;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    // This makes sure this specific lines are removed in production\n                    if (true) {\n                        webpackHMR = opts.webpackHMR;\n                    }\n                    initialErr = hydrateErr;\n                    _ctx.prev = 2;\n                    _ctx.next = 5;\n                    return pageLoader.routeLoader.whenEntrypoint('/_app');\n                case 5:\n                    appEntrypoint = _ctx.sent;\n                    if (!('error' in appEntrypoint)) {\n                        _ctx.next = 8;\n                        break;\n                    }\n                    throw appEntrypoint.error;\n                case 8:\n                    var ref;\n                    ref = appEntrypoint, app = ref.component, mod = ref.exports, ref;\n                    CachedApp = app;\n                    exportedReportWebVitals = mod && mod.reportWebVitals;\n                    onPerfEntry = function(param) {\n                        var id = param.id, name = param.name, startTime = param.startTime, value = param.value, duration = param.duration, entryType = param.entryType, entries = param.entries;\n                        // Combines timestamp with random number for unique ID\n                        var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9000000000000 - 1)) + 1000000000000);\n                        var perfStartEntry;\n                        if (entries && entries.length) {\n                            perfStartEntry = entries[0].startTime;\n                        }\n                        var webVitals = {\n                            id: id || uniqueID,\n                            name: name,\n                            startTime: startTime || perfStartEntry,\n                            value: value == null ? duration : value,\n                            label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                        };\n                        exportedReportWebVitals === null || exportedReportWebVitals === void 0 ? void 0 : exportedReportWebVitals(webVitals);\n                        (0, _vitals).trackWebVitalMetric(webVitals);\n                    };\n                    if (// error, so we need to skip waiting for the entrypoint.\n                    !( true && hydrateErr)) {\n                        _ctx.next = 16;\n                        break;\n                    }\n                    _ctx.t0 = {\n                        error: hydrateErr\n                    };\n                    _ctx.next = 19;\n                    break;\n                case 16:\n                    _ctx.next = 18;\n                    return pageLoader.routeLoader.whenEntrypoint(page);\n                case 18:\n                    _ctx.t0 = _ctx.sent;\n                case 19:\n                    pageEntrypoint = _ctx.t0;\n                    if (!('error' in pageEntrypoint)) {\n                        _ctx.next = 22;\n                        break;\n                    }\n                    throw pageEntrypoint.error;\n                case 22:\n                    CachedComponent = pageEntrypoint.component;\n                    if (false) {}\n                    isValidElementType = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType;\n                    if (isValidElementType(CachedComponent)) {\n                        _ctx.next = 27;\n                        break;\n                    }\n                    throw new Error(\"The default export is not a React Component in page: \\\"\".concat(page, \"\\\"\"));\n                case 27:\n                    _ctx.next = 32;\n                    break;\n                case 29:\n                    _ctx.prev = 29;\n                    _ctx.t1 = _ctx[\"catch\"](2);\n                    // This catches errors like throwing in the top level of a module\n                    initialErr = (0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + '');\n                case 32:\n                    if (true) {\n                        getNodeError = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ \"./node_modules/@next/react-dev-overlay/lib/client.js\").getNodeError;\n                        // Server-side runtime errors need to be re-thrown on the client-side so\n                        // that the overlay is rendered.\n                        if (initialErr) {\n                            if (initialErr === hydrateErr) {\n                                setTimeout(function() {\n                                    var error;\n                                    try {\n                                        // Generate a new error object. We `throw` it because some browsers\n                                        // will set the `stack` when thrown, and we want to ensure ours is\n                                        // not overridden when we re-throw it below.\n                                        throw new Error(initialErr.message);\n                                    } catch (e) {\n                                        error = e;\n                                    }\n                                    error.name = initialErr.name;\n                                    error.stack = initialErr.stack;\n                                    // Errors from the middleware are reported as client-side errors\n                                    // since the middleware is compiled using the client compiler\n                                    if ('middleware' in hydrateErr) {\n                                        throw error;\n                                    }\n                                    var node = getNodeError(error);\n                                    throw node;\n                                });\n                            } else {\n                                setTimeout(function() {\n                                    throw initialErr;\n                                });\n                            }\n                        }\n                    }\n                    if (!window.__NEXT_PRELOADREADY) {\n                        _ctx.next = 36;\n                        break;\n                    }\n                    _ctx.next = 36;\n                    return window.__NEXT_PRELOADREADY(dynamicIds);\n                case 36:\n                    exports.router = router = (0, _router1).createRouter(page, query, asPath, {\n                        initialProps: hydrateProps,\n                        pageLoader: pageLoader,\n                        App: CachedApp,\n                        Component: CachedComponent,\n                        wrapApp: wrapApp,\n                        err: initialErr,\n                        isFallback: Boolean(isFallback),\n                        subscription: function(info, App, scroll) {\n                            return render(Object.assign({\n                            }, info, {\n                                App: App,\n                                scroll: scroll\n                            }));\n                        },\n                        locale: locale,\n                        locales: locales,\n                        defaultLocale: defaultLocale,\n                        domainLocales: domainLocales,\n                        isPreview: isPreview\n                    });\n                    renderCtx = {\n                        App: CachedApp,\n                        initial: true,\n                        Component: CachedComponent,\n                        props: hydrateProps,\n                        err: initialErr\n                    };\n                    if (true) {\n                        _ctx.next = 43;\n                        break;\n                    }\n                    render(renderCtx);\n                    return _ctx.abrupt(\"return\", emitter);\n                case 43:\n                    return _ctx.abrupt(\"return\", {\n                        emitter: emitter,\n                        renderCtx: renderCtx\n                    });\n                case 44:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                2,\n                29\n            ]\n        ]);\n    }));\n    return _initNext.apply(this, arguments);\n}\nfunction initNext() {\n    return _initNext.apply(this, arguments);\n}\nfunction _render() {\n    _render = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(renderingProps) {\n        var renderErr;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (!renderingProps.err) {\n                        _ctx.next = 4;\n                        break;\n                    }\n                    _ctx.next = 3;\n                    return renderError(renderingProps);\n                case 3:\n                    return _ctx.abrupt(\"return\");\n                case 4:\n                    _ctx.prev = 4;\n                    _ctx.next = 7;\n                    return doRender(renderingProps);\n                case 7:\n                    _ctx.next = 17;\n                    break;\n                case 9:\n                    _ctx.prev = 9;\n                    _ctx.t0 = _ctx[\"catch\"](4);\n                    renderErr = _instanceof(_ctx.t0, Error) ? _ctx.t0 : new Error(_ctx.t0 + '');\n                    if (!renderErr.cancelled) {\n                        _ctx.next = 14;\n                        break;\n                    }\n                    throw renderErr;\n                case 14:\n                    if (true) {\n                        // Ensure this error is displayed in the overlay in development\n                        setTimeout(function() {\n                            throw renderErr;\n                        });\n                    }\n                    _ctx.next = 17;\n                    return renderError(_objectSpread({\n                    }, renderingProps, {\n                        err: renderErr\n                    }));\n                case 17:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                4,\n                9\n            ]\n        ]);\n    }));\n    return _render.apply(this, arguments);\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction renderError(renderErrorProps) {\n    var App = renderErrorProps.App, err = renderErrorProps.err;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: function() {\n                return null;\n            },\n            props: {\n            },\n            Component: function() {\n                return null;\n            },\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage('/_error').then(function(param) {\n        var ErrorComponent = param.page, styleSheets = param.styleSheets;\n        return (lastAppProps === null || lastAppProps === void 0 ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(function() {\n            return _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"));\n        }).then(function(m) {\n            return {\n                ErrorComponent: m.default,\n                styleSheets: []\n            };\n        }) : {\n            ErrorComponent: ErrorComponent,\n            styleSheets: styleSheets\n        };\n    }).then(function(param) {\n        var ErrorComponent = param.ErrorComponent, styleSheets = param.styleSheets;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        var AppTree = wrapApp(App);\n        var appCtx = {\n            Component: ErrorComponent,\n            AppTree: AppTree,\n            router: router,\n            ctx: {\n                err: err,\n                pathname: page,\n                query: query,\n                asPath: asPath,\n                AppTree: AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function(initProps) {\n            return doRender(_objectSpread({\n            }, renderErrorProps, {\n                err: err,\n                Component: ErrorComponent,\n                styleSheets: styleSheets,\n                props: initProps\n            }));\n        });\n    });\n}\nvar reactRoot = null;\n// On initial render a hydrate should always happen\nvar shouldHydrate = true;\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark('beforeRender');\n    }\n    var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (false) {} else {\n        // The check for `.hydrate` is there to support React alternatives like preact\n        if (shouldHydrate) {\n            _reactDom.default.hydrate(reactEl, domEl);\n            shouldHydrate = false;\n        } else {\n            _reactDom.default.render(reactEl, domEl);\n        }\n    }\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterHydrate') // mark end of hydration\n    ;\n    performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');\n    performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark('afterRender') // mark end of render\n    ;\n    var navStartEntries = performance.getEntriesByName('routeChange', 'mark');\n    if (!navStartEntries.length) return;\n    performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');\n    performance.measure('Next.js-render', 'beforeRender', 'afterRender');\n    if (onPerfEntry) {\n        performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);\n        performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        'Next.js-route-change-to-render',\n        'Next.js-render'\n    ].forEach(function(measure) {\n        return performance.clearMeasures(measure);\n    });\n}\nfunction clearMarks() {\n    [\n        'beforeRender',\n        'afterHydrate',\n        'afterRender',\n        'routeChange'\n    ].forEach(function(mark) {\n        return performance.clearMarks(mark);\n    });\n}\nfunction AppContainer(param) {\n    var children = param.children;\n    return(/*#__PURE__*/ _react.default.createElement(Container, {\n        fn: function(error) {\n            return renderError({\n                App: CachedApp,\n                err: error\n            }).catch(function(err) {\n                return console.error('Error rendering page: ', err);\n            });\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router1).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_styledJsx.StyleRegistry, null, children)))));\n}\n_c = AppContainer;\nvar wrapApp = function(App) {\n    return function(wrappedAppProps) {\n        var appProps = _objectSpread({\n        }, wrappedAppProps, {\n            Component: CachedComponent,\n            err: hydrateErr,\n            router: router\n        });\n        return(/*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n        }, appProps))));\n    };\n};\nvar RSCComponent;\nif (false) { var RSCWrapper, rscCache, _s2, createResponseCache; }\nvar lastAppProps;\nfunction doRender(input) {\n    var onStart = // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // unless we're in production:\n        'development' !== 'production') {\n            return false;\n        }\n        var currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        var currentHrefs = new Set(currentStyleTags.map(function(tag) {\n            return tag.getAttribute('data-n-href');\n        }));\n        var noscript = document.querySelector('noscript[data-n-css]');\n        var nonce = noscript === null || noscript === void 0 ? void 0 : noscript.getAttribute('data-n-css');\n        styleSheets.forEach(function(param) {\n            var href = param.href, text = param.text;\n            if (!currentHrefs.has(href)) {\n                var styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    };\n    var onHeadCommit = function onHeadCommit() {\n        if (// unless we're in production:\n        false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n        if (input.scroll) {\n            window.scrollTo(input.scroll.x, input.scroll.y);\n        }\n    };\n    var onRootCommit = function onRootCommit() {\n        resolvePromise();\n    };\n    var App = input.App, Component = input.Component, props = input.props, err = input.err, __N_RSC = input.__N_RSC;\n    var styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    var isRSC =  false ? 0 : !!__N_RSC;\n    var appProps = _objectSpread({\n    }, props, {\n        Component: isRSC ? RSCComponent : Component,\n        err: err,\n        router: router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    var canceled = false;\n    var resolvePromise;\n    var renderPromise = new Promise(function(resolve, reject) {\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = function() {\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = function() {\n            canceled = true;\n            lastRenderReject = null;\n            var error = new Error('Cancel rendering route');\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    onStart();\n    var elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, /*#__PURE__*/ _react.default.createElement(App, Object.assign({\n    }, appProps)), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, function(callback) {\n        /*#__PURE__*/ return _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem);\n    });\n    return renderPromise;\n}\nfunction Root(param) {\n    var callbacks = param.callbacks, children = param.children;\n    _s3();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(function() {\n        return callbacks.forEach(function(callback) {\n            return callback();\n        });\n    }, [\n        callbacks\n    ]);\n    if (undefined) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        _react.default.useEffect(function() {\n            window.__NEXT_HYDRATED = true;\n            if (window.__NEXT_HYDRATED_CB) {\n                window.__NEXT_HYDRATED_CB();\n            }\n        }, []);\n    }\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(function() {\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    return children;\n}\n_s3(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c1 = Root;\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    var callback = param.callback;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(function() {\n        return callback();\n    }, [\n        callback\n    ]);\n    return null;\n} //# sourceMappingURL=index.js.map\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Head;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Root\");\n$RefreshReg$(_c2, \"Head\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFLFFBQVE7QUFDM0JGLGNBQWMsR0FBR0csTUFBTTtBQUN2QkgsbUJBQW1CLEdBQUdJLFdBQVc7QUFDakNKLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDM0RRLG1CQUFPLENBQUMsMkZBQXVCO0FBQy9CLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHQyx1QkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyw0Q0FBTztBQUNuRCxHQUFHLENBQUNHLFNBQVMsR0FBR0QsdUJBQXNCLENBQUNGLG1CQUFPLENBQUMsb0RBQVc7QUFDMUQsR0FBRyxDQUFDSSxVQUFVLEdBQUdKLG1CQUFPLENBQUMsc0RBQVk7QUFDckMsR0FBRyxDQUFDSyxtQkFBbUIsR0FBR0wsbUJBQU8sQ0FBQyx1R0FBb0M7QUFDdEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdKLHVCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFvQjtBQUMvRCxHQUFHLENBQUNPLGNBQWMsR0FBR1AsbUJBQU8sQ0FBQywyRkFBOEI7QUFDM0QsR0FBRyxDQUFDUSxPQUFPLEdBQUdSLG1CQUFPLENBQUMseUZBQTZCO0FBQ25ELEdBQUcsQ0FBQ1MsVUFBVSxHQUFHVCxtQkFBTyxDQUFDLDZHQUF1QztBQUNoRSxHQUFHLENBQUNVLFlBQVksR0FBR1YsbUJBQU8sQ0FBQyxvSEFBd0M7QUFDbkUsR0FBRyxDQUFDVyxjQUFjLEdBQUdYLG1C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QUFDO2dCQUM1QnZRLE1BQU0sQ0FBQ3VRLGtCQUFrQjtZQUM3QixDQUFDO1FBQ0wsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7SUFDRCxFQUEwRTtJQUMxRSxFQUFtQztJQUNuQ2xWLE1BQU0sQ0FBQytDLE9BQU8sQ0FBQ2lTLFNBQVMsQ0FBQyxRQUMzQixHQUQrQixDQUFDO1NBQ3pCLENBQUMsRUFBRWpVLG1CQUFtQixFQUFFZ0MsT0FBTyxDQUFDMkYsV0FBVztJQUNoRCxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ0wsTUFBTSxDQUFDeUIsUUFBUTtBQUNuQixDQUFDO0lBdkJRdUssSUFBSTtNQUFKQSxJQUFJO0FBd0JiLEVBQW1FO0FBQ25FLEVBQXlEO1NBQ2hETCxJQUFJLENBQUMsS0FBYSxFQUFFLENBQUM7UUFBZEMsUUFBUSxHQUFWLEtBQWEsQ0FBWEEsUUFBUTs7SUFDcEIsRUFBaUU7SUFDakUsRUFBdUM7SUFDdkN0VSxNQUFNLENBQUMrQyxPQUFPLENBQUMrUixlQUFlLENBQUMsUUFBUTtRQUFKUixNQUFNLENBQU5BLFFBQVE7T0FDekMsQ0FBQztRQUNDQSxRQUFRO0lBQ1osQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJO0FBQ2YsQ0FBQyxDQUVnQztJQVZ4QkQsSUFBSTtNQUFKQSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzPzQ2Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmluaXROZXh0ID0gaW5pdE5leHQ7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMucmVuZGVyRXJyb3IgPSByZW5kZXJFcnJvcjtcbmV4cG9ydHMuZW1pdHRlciA9IGV4cG9ydHMucm91dGVyID0gZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xucmVxdWlyZShcIkBuZXh0L3BvbHlmaWxsLW1vZHVsZVwiKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfc3R5bGVkSnN4ID0gcmVxdWlyZShcInN0eWxlZC1qc3hcIik7XG52YXIgX2hlYWRNYW5hZ2VyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0XCIpO1xudmFyIF9taXR0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9taXR0XCIpKTtcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3J1bnRpbWVDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZ1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbnZhciBfcG9ydGFsID0gcmVxdWlyZShcIi4vcG9ydGFsXCIpO1xudmFyIF9oZWFkTWFuYWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyXCIpKTtcbnZhciBfcGFnZUxvYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFnZS1sb2FkZXJcIikpO1xudmFyIF9wZXJmb3JtYW5jZVJlbGF5ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpO1xudmFyIF9yb3V0ZUFubm91bmNlciA9IHJlcXVpcmUoXCIuL3JvdXRlLWFubm91bmNlclwiKTtcbnZhciBfcm91dGVyMSA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX3ZpdGFscyA9IHJlcXVpcmUoXCIuL3ZpdGFsc1wiKTtcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge1xuICAgICAgICB9O1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fTkVYVF9EQVRBX18nKS50ZXh0Q29udGVudCk7XG53aW5kb3cuX19ORVhUX0RBVEFfXyA9IGRhdGE7XG5jb25zdCB2ZXJzaW9uID0gXCIxMi4wLjJcIjtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5jb25zdCBsb29zZVRvQXJyYXkgPSAoaW5wdXQpPT5bXS5zbGljZS5jYWxsKGlucHV0KVxuO1xuY29uc3QgeyBwcm9wczogaHlkcmF0ZVByb3BzICwgZXJyOiBoeWRyYXRlRXJyICwgcGFnZSAsIHF1ZXJ5ICwgYnVpbGRJZCAsIGFzc2V0UHJlZml4ICwgcnVudGltZUNvbmZpZyAsIGR5bmFtaWNJZHMgLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgLCByc2MgLCAgfSA9IGRhdGE7XG5sZXQgeyBkZWZhdWx0TG9jYWxlICB9ID0gZGF0YTtcbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnO1xuLy8gV2l0aCBkeW5hbWljIGFzc2V0UHJlZml4IGl0J3Mgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldCBhc3NldFByZWZpeCBhdCB0aGUgYnVpbGQgdGltZVxuLy8gU28sIHRoaXMgaXMgaG93IHdlIGRvIGl0IGluIHRoZSBjbGllbnQgc2lkZSBhdCBydW50aW1lXG5fX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGAke3ByZWZpeH0vX25leHQvYCAvL2VzbGludC1kaXNhYmxlLWxpbmVcbjtcbi8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuKDAsIF9ydW50aW1lQ29uZmlnKS5zZXRDb25maWcoe1xuICAgIHNlcnZlclJ1bnRpbWVDb25maWc6IHtcbiAgICB9LFxuICAgIHB1YmxpY1J1bnRpbWVDb25maWc6IHJ1bnRpbWVDb25maWcgfHwge1xuICAgIH1cbn0pO1xubGV0IGFzUGF0aCA9ICgwLCBfdXRpbHMpLmdldFVSTCgpO1xuLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuaWYgKCgwLCBfcm91dGVyKS5oYXNCYXNlUGF0aChhc1BhdGgpKSB7XG4gICAgYXNQYXRoID0gKDAsIF9yb3V0ZXIpLmRlbEJhc2VQYXRoKGFzUGF0aCk7XG59XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGNvbnN0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKTtcbiAgICBjb25zdCB7IGRldGVjdERvbWFpbkxvY2FsZSAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpO1xuICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpO1xuICAgIGNvbnN0IHsgZm9ybWF0VXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCcpO1xuICAgIGlmIChsb2NhbGVzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgbG9jYWxlcyk7XG4gICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVyaXZlIHRoZSBkZWZhdWx0IGxvY2FsZSBpZiBpdCB3YXNuJ3QgZGV0ZWN0ZWQgaW4gdGhlIGFzUGF0aFxuICAgICAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBsb2NhbGVzXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGVtcHQgZGV0ZWN0aW5nIGRlZmF1bHQgbG9jYWxlIGJhc2VkIG9uIGhvc3RuYW1lXG4gICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMsIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgICAgIC8vIGh5ZHJhdGlvbiB0byBwcmV2ZW50IG1pc21hdGNoZWQgcmVuZGVyc1xuICAgICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKGRhdGEuc2NyaXB0TG9hZGVyKSB7XG4gICAgY29uc3QgeyBpbml0U2NyaXB0TG9hZGVyICB9ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbiAgICBpbml0U2NyaXB0TG9hZGVyKGRhdGEuc2NyaXB0TG9hZGVyKTtcbn1cbmNvbnN0IHBhZ2VMb2FkZXIgPSBuZXcgX3BhZ2VMb2FkZXIuZGVmYXVsdChidWlsZElkLCBwcmVmaXgpO1xuY29uc3QgcmVnaXN0ZXIgPSAoW3IsIGZdKT0+cGFnZUxvYWRlci5yb3V0ZUxvYWRlci5vbkVudHJ5cG9pbnQociwgZilcbjtcbmlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAvLyBsYXRlbmN5IGluIGh5ZHJhdGluZyB0aGUgcGFnZSwgYnV0IHJlZHVjZSB0aGUgdG90YWwgYmxvY2tpbmcgdGltZS5cbiAgICB3aW5kb3cuX19ORVhUX1AubWFwKChwKT0+c2V0VGltZW91dCgoKT0+cmVnaXN0ZXIocClcbiAgICAgICAgLCAwKVxuICAgICk7XG59XG53aW5kb3cuX19ORVhUX1AgPSBbXTtcbndpbmRvdy5fX05FWFRfUC5wdXNoID0gcmVnaXN0ZXI7XG5jb25zdCBoZWFkTWFuYWdlciA9ICgwLCBfaGVhZE1hbmFnZXIpLmRlZmF1bHQoKTtcbmNvbnN0IGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0Jyk7XG5sZXQgbGFzdFJlbmRlclJlamVjdDtcbmxldCB3ZWJwYWNrSE1SO1xubGV0IHJvdXRlcjtcbmV4cG9ydHMucm91dGVyID0gcm91dGVyO1xubGV0IENhY2hlZEFwcCwgb25QZXJmRW50cnk7XG5oZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpPT57XG4gICAgcmV0dXJuIHJvdXRlci5pc1Nzcjtcbn07XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVyciwgaW5mbykge1xuICAgICAgICB0aGlzLnByb3BzLmZuKGNvbXBvbmVudEVyciwgaW5mbyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAgICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgICAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICAgICAgaWYgKHJvdXRlci5pc1NzciAmJiAvLyBXZSBkb24ndCB1cGRhdGUgZm9yIDQwNCByZXF1ZXN0cyBhcyB0aGlzIGNhbiBtb2RpZnlcbiAgICAgICAgLy8gdGhlIGFzUGF0aCB1bmV4cGVjdGVkbHkgZS5nLiBhZGRpbmcgYmFzZVBhdGggd2hlblxuICAgICAgICAvLyBpdCB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50XG4gICAgICAgIHBhZ2UgIT09ICcvNDA0JyAmJiBwYWdlICE9PSAnL19lcnJvcicgJiYgKGlzRmFsbGJhY2sgfHwgZGF0YS5uZXh0RXhwb3J0ICYmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykgfHwgaHlkcmF0ZVByb3BzICYmIGh5ZHJhdGVQcm9wcy5fX05fU1NHICYmIChsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocm91dGVyLnF1ZXJ5KSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksIGFzUGF0aCwge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgICAgIF9oOiAxLFxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBub3Qgc2hhbGxvdy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBwYWdlcyAoc3RyaWN0bHkgdXBkYXRpbmcgcXVlcnkpIGhhcHBlbnMgc2hhbGxvd2x5LCBhcyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgICBzaGFsbG93OiAhaXNGYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goKSB7XG4gICAgICAgIGxldCB7IGhhc2ggIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+ZWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAsIDApO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgUmVhY3REZXZPdmVybGF5ICB9ID0gcmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdERldk92ZXJsYXksIG51bGwsIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGVtaXR0ZXIgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZW1pdHRlciA9IGVtaXR0ZXI7XG5sZXQgQ2FjaGVkQ29tcG9uZW50O1xuZnVuY3Rpb24gX2luaXROZXh0KCkge1xuICAgIF9pbml0TmV4dCA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKihvcHRzID0ge1xuICAgIH0pIHtcbiAgICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHdlYnBhY2tITVIgPSBvcHRzLndlYnBhY2tITVI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXRpYWxFcnIgPSBoeWRyYXRlRXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBwRW50cnlwb2ludCA9IHlpZWxkIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJyk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXBwRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50OiBhcHAgLCBleHBvcnRzOiBtb2QgIH0gPSBhcHBFbnRyeXBvaW50O1xuICAgICAgICAgICAgQ2FjaGVkQXBwID0gYXBwO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMgPSBtb2QgJiYgbW9kLnJlcG9ydFdlYlZpdGFscztcbiAgICAgICAgICAgIG9uUGVyZkVudHJ5ID0gKHsgaWQgLCBuYW1lICwgc3RhcnRUaW1lICwgdmFsdWUgLCBkdXJhdGlvbiAsIGVudHJ5VHlwZSAsIGVudHJpZXMgIH0pPT57XG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBgJHtEYXRlLm5vdygpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5MDAwMDAwMDAwMDAwIC0gMSkpICsgMTAwMDAwMDAwMDAwMH1gO1xuICAgICAgICAgICAgICAgIGxldCBwZXJmU3RhcnRFbnRyeTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwZXJmU3RhcnRFbnRyeSA9IGVudHJpZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3ZWJWaXRhbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgfHwgcGVyZlN0YXJ0RW50cnksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnID8gJ2N1c3RvbScgOiAnd2ViLXZpdGFsJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMgPT09IG51bGwgfHwgZXhwb3J0ZWRSZXBvcnRXZWJWaXRhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cG9ydGVkUmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscyk7XG4gICAgICAgICAgICAgICAgKDAsIF92aXRhbHMpLnRyYWNrV2ViVml0YWxNZXRyaWMod2ViVml0YWxzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwYWdlRW50cnlwb2ludCA9IC8vIFRoZSBkZXYgc2VydmVyIGZhaWxzIHRvIHNlcnZlIHNjcmlwdCBhc3NldHMgd2hlbiB0aGVyZSdzIGEgaHlkcmF0aW9uXG4gICAgICAgICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaHlkcmF0ZUVyciA/IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogaHlkcmF0ZUVyclxuICAgICAgICAgICAgfSA6IHlpZWxkIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQocGFnZSk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBwYWdlRW50cnlwb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVkQ29tcG9uZW50ID0gcGFnZUVudHJ5cG9pbnQuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSAgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhZ2V9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIGxpa2UgdGhyb3dpbmcgaW4gdGhlIHRvcCBsZXZlbCBvZiBhIG1vZHVsZVxuICAgICAgICAgICAgaW5pdGlhbEVyciA9ICgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnJvcikgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvciArICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0Tm9kZUVycm9yICB9ID0gcmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpO1xuICAgICAgICAgICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBvdmVybGF5IGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgaWYgKGluaXRpYWxFcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaHlkcmF0ZUVycikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvcnMgZnJvbSB0aGUgbWlkZGxld2FyZSBhcmUgcmVwb3J0ZWQgYXMgY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgbWlkZGxld2FyZSBpcyBjb21waWxlZCB1c2luZyB0aGUgY2xpZW50IGNvbXBpbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ21pZGRsZXdhcmUnIGluIGh5ZHJhdGVFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5pdGlhbEVycjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgICAgICAgICAgeWllbGQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoZHluYW1pY0lkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXIgPSAoMCwgX3JvdXRlcjEpLmNyZWF0ZVJvdXRlcihwYWdlLCBxdWVyeSwgYXNQYXRoLCB7XG4gICAgICAgICAgICBpbml0aWFsUHJvcHM6IGh5ZHJhdGVQcm9wcyxcbiAgICAgICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVycixcbiAgICAgICAgICAgIGlzRmFsbGJhY2s6IEJvb2xlYW4oaXNGYWxsYmFjayksXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIEFwcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBsb2NhbGVzLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgICAgICAgICBpc1ByZXZpZXdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlbmRlckN0eCA9IHtcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHM6IGh5ZHJhdGVQcm9wcyxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVyclxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlcixcbiAgICAgICAgICAgICAgICByZW5kZXJDdHhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2luaXROZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBpbml0TmV4dCgpIHtcbiAgICByZXR1cm4gX2luaXROZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgIF9yZW5kZXIgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbioocmVuZGVyaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyRXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoZXJyICsgJycpO1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBlcnJvciBpcyBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXkgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlbmRlckVycm9yKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgfSwgcmVuZGVyaW5nUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihyZW5kZXJpbmdQcm9wcykge1xuICAgIHJldHVybiBfcmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzKSB7XG4gICAgY29uc3QgeyBBcHAgLCBlcnIgIH0gPSByZW5kZXJFcnJvclByb3BzO1xuICAgIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgICAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAgICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgIEFwcDogKCk9Pm51bGxcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ29tcG9uZW50OiAoKT0+bnVsbFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKGBBIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQsIHNlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2NsaWVudC1zaWRlLWV4Y2VwdGlvbi1vY2N1cnJlZGApO1xuICAgIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKCcvX2Vycm9yJykudGhlbigoeyBwYWdlOiBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICByZXR1cm4gKGxhc3RBcHBQcm9wcyA9PT0gbnVsbCB8fCBsYXN0QXBwUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RBcHBQcm9wcy5Db21wb25lbnQpID09PSBFcnJvckNvbXBvbmVudCA/IGltcG9ydCgnLi4vcGFnZXMvX2Vycm9yJykudGhlbigobSk9Pih7XG4gICAgICAgICAgICAgICAgRXJyb3JDb21wb25lbnQ6IG0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgICAgIH0pXG4gICAgICAgICkgOiB7XG4gICAgICAgICAgICBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzXG4gICAgICAgIH07XG4gICAgfSkudGhlbigoeyBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcCk7XG4gICAgICAgIGNvbnN0IGFwcEN0eCA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgcm91dGVyLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBwYWdlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICBBcHBUcmVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA/IHJlbmRlckVycm9yUHJvcHMucHJvcHMgOiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgYXBwQ3R4KSkudGhlbigoaW5pdFByb3BzKT0+ZG9SZW5kZXIoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICB9LCByZW5kZXJFcnJvclByb3BzLCB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRQcm9wc1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgfSk7XG59XG5sZXQgcmVhY3RSb290ID0gbnVsbDtcbi8vIE9uIGluaXRpYWwgcmVuZGVyIGEgaHlkcmF0ZSBzaG91bGQgYWx3YXlzIGhhcHBlblxubGV0IHNob3VsZEh5ZHJhdGUgPSB0cnVlO1xuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KGRvbUVsLCBmbikge1xuICAgIC8vIG1hcmsgc3RhcnQgb2YgaHlkcmF0ZS9yZW5kZXJcbiAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2JlZm9yZVJlbmRlcicpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfUk9PVCkge1xuICAgICAgICBpZiAoIXJlYWN0Um9vdCkge1xuICAgICAgICAgICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgICAgICAgICAgcmVhY3RSb290ID0gX3JlYWN0RG9tLmRlZmF1bHQuaHlkcmF0ZVJvb3QoZG9tRWwsIHJlYWN0RWwpO1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgICAgICAgICAgc2hvdWxkSHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhY3RSb290LnJlbmRlcihyZWFjdEVsKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjaGVjayBmb3IgYC5oeWRyYXRlYCBpcyB0aGVyZSB0byBzdXBwb3J0IFJlYWN0IGFsdGVybmF0aXZlcyBsaWtlIHByZWFjdFxuICAgICAgICBpZiAoc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgICAgICAgX3JlYWN0RG9tLmRlZmF1bHQuaHlkcmF0ZShyZWFjdEVsLCBkb21FbCk7XG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5yZW5kZXIocmVhY3RFbCwgZG9tRWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVySHlkcmF0ZScpIC8vIG1hcmsgZW5kIG9mIGh5ZHJhdGlvblxuICAgIDtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLCAnbmF2aWdhdGlvblN0YXJ0JywgJ2JlZm9yZVJlbmRlcicpO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtaHlkcmF0aW9uJywgJ2JlZm9yZVJlbmRlcicsICdhZnRlckh5ZHJhdGUnKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICB9XG4gICAgY2xlYXJNYXJrcygpO1xufVxuZnVuY3Rpb24gbWFya1JlbmRlckNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJSZW5kZXInKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgICA7XG4gICAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgncm91dGVDaGFuZ2UnLCAnbWFyaycpO1xuICAgIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yZW5kZXInLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVyUmVuZGVyJyk7XG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG4gICAgW1xuICAgICAgICAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgICAgICAgJ05leHQuanMtcmVuZGVyJ1xuICAgIF0uZm9yRWFjaCgobWVhc3VyZSk9PnBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZSlcbiAgICApO1xufVxuZnVuY3Rpb24gY2xlYXJNYXJrcygpIHtcbiAgICBbXG4gICAgICAgICdiZWZvcmVSZW5kZXInLFxuICAgICAgICAnYWZ0ZXJIeWRyYXRlJyxcbiAgICAgICAgJ2FmdGVyUmVuZGVyJyxcbiAgICAgICAgJ3JvdXRlQ2hhbmdlJ1xuICAgIF0uZm9yRWFjaCgobWFyayk9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFyaylcbiAgICApO1xufVxuZnVuY3Rpb24gQXBwQ29udGFpbmVyKHsgY2hpbGRyZW4gIH0pIHtcbiAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwge1xuICAgICAgICBmbjogKGVycm9yKT0+cmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT5jb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgcGFnZTogJywgZXJyKVxuICAgICAgICAgICAgKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX3JvdXRlcjEpLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkTWFuYWdlckNvbnRleHQuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBoZWFkTWFuYWdlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfc3R5bGVkSnN4LlN0eWxlUmVnaXN0cnksIG51bGwsIGNoaWxkcmVuKSkpKSk7XG59XG5jb25zdCB3cmFwQXBwID0gKEFwcCk9Pih3cmFwcGVkQXBwUHJvcHMpPT57XG4gICAgICAgIGNvbnN0IGFwcFByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICAgIH0sIHdyYXBwZWRBcHBQcm9wcywge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBlcnI6IGh5ZHJhdGVFcnIsXG4gICAgICAgICAgICByb3V0ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgfSwgYXBwUHJvcHMpKSkpO1xuICAgIH1cbjtcbmxldCBSU0NDb21wb25lbnQ7XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX1JTQykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGNvbnN0IHJzY0NhY2hlID0gY3JlYXRlUmVzcG9uc2VDYWNoZSgpO1xuICAgIGNvbnN0IFJTQ1dyYXBwZXIgPSAoeyBjYWNoZUtleSAsIHNlcmlhbGl6ZWQgLCBfZnJlc2ggIH0pPT57XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlRnJvbUZldGNoICwgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrJyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHJzY0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNhY2hlLCBvciB0aGVyZSBpcyBzZXJpYWxpemVkIGRhdGEgYWxyZWFkeVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGNyZWF0ZUZyb21GZXRjaChzZXJpYWxpemVkID8gKCgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICAgICAgICAgICAgICB0LndyaXRhYmxlLmdldFdyaXRlcigpLndyaXRlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZXJpYWxpemVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHQucmVhZGFibGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCkgOiAoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0UmVxVXJsID0gbG9jYXRpb24ucGF0aG5hbWUgKyBzZWFyY2ggKyAoc2VhcmNoID8gJyZfX2ZsaWdodF9fJyA6ICc/X19mbGlnaHRfXycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaChmbGlnaHRSZXFVcmwpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICByc2NDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290ID0gcmVzcG9uc2UucmVhZFJvb3QoKTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgICBSU0NDb21wb25lbnQgPSAocHJvcHMpPT57XG4gICAgICAgIGNvbnN0IHsgYXNQYXRoOiBjYWNoZUtleSAgfSA9ICgwLCBfcm91dGVyMSkudXNlUm91dGVyKCk7XG4gICAgICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiBudWxsXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSU0NXcmFwcGVyLCB7XG4gICAgICAgICAgICBjYWNoZUtleTogY2FjaGVLZXksXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBwcm9wcy5fX2ZsaWdodF9zZXJpYWxpemVkX18sXG4gICAgICAgICAgICBfZnJlc2g6IHByb3BzLl9fZmxpZ2h0X2ZyZXNoX19cbiAgICAgICAgfSkpKTtcbiAgICB9O1xufVxubGV0IGxhc3RBcHBQcm9wcztcbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0KSB7XG4gICAgbGV0IHsgQXBwICwgQ29tcG9uZW50ICwgcHJvcHMgLCBlcnIgLCBfX05fUlNDICB9ID0gaW5wdXQ7XG4gICAgbGV0IHN0eWxlU2hlZXRzID0gJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgaXNSU0MgPSBwcm9jZXNzLmVudi5fX05FWFRfUlNDICYmICdpbml0aWFsJyBpbiBpbnB1dCA/ICEhcnNjIDogISFfX05fUlNDO1xuICAgIGNvbnN0IGFwcFByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgfSwgcHJvcHMsIHtcbiAgICAgICAgQ29tcG9uZW50OiBpc1JTQyA/IFJTQ0NvbXBvbmVudCA6IENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9KTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gICAgLy8gUHJvbWlzZS4gSXQgc2hvdWxkIHJlbWFpbiBzeW5jaHJvbm91cy5cbiAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBpZiAoIXN0eWxlU2hlZXRzIHx8IC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJykpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCBub3NjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT09IG51bGwgfHwgbm9zY3JpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpO1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgLCB0ZXh0ICB9KT0+e1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50SHJlZnMuaGFzKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpIHtcbiAgICAgICAgaWYgKC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAvLyBXZSBjYW4gc2tpcCB0aGlzIGR1cmluZyBoeWRyYXRpb24uIFJ1bm5pbmcgaXQgd29udCBjYXVzZSBhbnkgaGFybSwgYnV0XG4gICAgICAgIC8vIHdlIG1heSBhcyB3ZWxsIHNhdmUgdGhlIENQVSBjeWNsZXM6XG4gICAgICAgIHN0eWxlU2hlZXRzICYmIC8vIEVuc3VyZSB0aGlzIHJlbmRlciB3YXMgbm90IGNhbmNlbGVkXG4gICAgICAgICFjYW5jZWxlZCkge1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZEhyZWZzID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpPT5zLmhyZWZcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKT0+dGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgICAgICAgZm9yKGxldCBpZHggPSAwOyBpZHggPCBjdXJyZW50SHJlZnMubGVuZ3RoOyArK2lkeCl7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJykpLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKGlucHV0LnNjcm9sbC54LCBpbnB1dC5zY3JvbGwueSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Sb290Q29tbWl0KCkge1xuICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgZWxlbSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhlYWQsIHtcbiAgICAgICAgY2FsbGJhY2s6IG9uSGVhZENvbW1pdFxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBPYmplY3QuYXNzaWduKHtcbiAgICB9LCBhcHBQcm9wcykpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZUFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSlcbiAgICApO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuZnVuY3Rpb24gUm9vdCh7IGNhbGxiYWNrcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2tzIGFyZSBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spPT5jYWxsYmFjaygpXG4gICAgICAgIClcbiAgICAsIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICAvLyBXZSBzaG91bGQgYXNrIHRvIG1lYXN1cmUgdGhlIFdlYiBWaXRhbHMgYWZ0ZXIgcmVuZGVyaW5nIGNvbXBsZXRlcyBzbyB3ZVxuICAgIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfcGVyZm9ybWFuY2VSZWxheWVyKS5kZWZhdWx0KG9uUGVyZkVudHJ5KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHsgY2FsbGJhY2sgIH0pIHtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKVxuICAgICwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0TmV4dCIsInJlbmRlciIsInJlbmRlckVycm9yIiwiZW1pdHRlciIsInJvdXRlciIsInZlcnNpb24iLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9zdHlsZWRKc3giLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX21pdHQiLCJfcm91dGVyQ29udGV4dCIsIl9yb3V0ZXIiLCJfaXNEeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVDb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiX3JvdXRlQW5ub3VuY2VyIiwiX3JvdXRlcjEiLCJfaXNFcnJvciIsIl92aXRhbHMiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJuZXdPYmoiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsImkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImZvckVhY2giLCJsZW5ndGgiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJoeWRyYXRlUHJvcHMiLCJwcm9wcyIsImh5ZHJhdGVFcnIiLCJwYWdlIiwicXVlcnkiLCJidWlsZElkIiwiYXNzZXRQcmVmaXgiLCJydW50aW1lQ29uZmlnIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInJzYyIsImRlZmF1bHRMb2NhbGUiLCJwcmVmaXgiLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsInNldENvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiYXNQYXRoIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdERvbWFpbkxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJmb3JtYXRVcmwiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJwYXRobmFtZSIsImRldGVjdGVkTG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwibG9jYXRpb24iLCJob3N0bmFtZSIsInNjcmlwdExvYWRlciIsImluaXRTY3JpcHRMb2FkZXIiLCJwYWdlTG9hZGVyIiwicmVnaXN0ZXIiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwic2V0VGltZW91dCIsInB1c2giLCJoZWFkTWFuYWdlciIsImFwcEVsZW1lbnQiLCJsYXN0UmVuZGVyUmVqZWN0Iiwid2VicGFja0hNUiIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiZ2V0SXNTc3IiLCJpc1NzciIsIkNvbnRhaW5lciIsImNvbXBvbmVudERpZENhdGNoIiwiY29tcG9uZW50RXJyIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJDYWNoZWRDb21wb25lbnQiLCJfaW5pdE5leHQiLCJvcHRzIiwiaW5pdGlhbEVyciIsImFwcEVudHJ5cG9pbnQiLCJhcHAiLCJtb2QiLCJleHBvcnRlZFJlcG9ydFdlYlZpdGFscyIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0Tm9kZUVycm9yIiwicmVuZGVyQ3R4Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJyZXBvcnRXZWJWaXRhbHMiLCJuYW1lIiwiaWQiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIk1hdGgiLCJEYXRlIiwibm93IiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwidHJhY2tXZWJWaXRhbE1ldHJpYyIsIkVycm9yIiwibWVzc2FnZSIsImUiLCJzdGFjayIsIm5vZGUiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJzY3JvbGwiLCJpbml0aWFsIiwiX3JlbmRlciIsInJlbmRlcmluZ1Byb3BzIiwicmVuZGVyRXJyIiwiZG9SZW5kZXIiLCJjYW5jZWxsZWQiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJzdHlsZVNoZWV0cyIsImNvbnNvbGUiLCJsb2FkUGFnZSIsIkVycm9yQ29tcG9uZW50IiwibGFzdEFwcFByb3BzIiwibSIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJyZWFjdEVsIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIl9fTkVYVF9SRUFDVF9ST09UIiwiaHlkcmF0ZVJvb3QiLCJoeWRyYXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsImNhdGNoIiwiUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiU3R5bGVSZWdpc3RyeSIsIndyYXBwZWRBcHBQcm9wcyIsImFwcFByb3BzIiwiUlNDQ29tcG9uZW50IiwiX19ORVhUX1JTQyIsImNyZWF0ZVJlc3BvbnNlQ2FjaGUiLCJNYXAiLCJyc2NDYWNoZSIsIlJTQ1dyYXBwZXIiLCJjYWNoZUtleSIsInNlcmlhbGl6ZWQiLCJfZnJlc2giLCJjcmVhdGVGcm9tRmV0Y2giLCJyZXNwb25zZSIsInQiLCJUcmFuc2Zvcm1TdHJlYW0iLCJnZXRXcml0ZXIiLCJ3cml0ZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYm9keSIsInJlYWRhYmxlIiwiZmxpZ2h0UmVxVXJsIiwiZmV0Y2giLCJyb290IiwicmVhZFJvb3QiLCJ1c2VSb3V0ZXIiLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwiX19mbGlnaHRfc2VyaWFsaXplZF9fIiwiX19mbGlnaHRfZnJlc2hfXyIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiY2FuY2VsZWQiLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsVG8iLCJ4IiwieSIsIm9uUm9vdENvbW1pdCIsInJlc29sdmVQcm9taXNlIiwiX19OX1JTQyIsImlzUlNDIiwicmVuZGVyUHJvbWlzZSIsImVsZW0iLCJGcmFnbWVudCIsIkhlYWQiLCJjYWxsYmFjayIsIlBvcnRhbCIsInR5cGUiLCJSb3V0ZUFubm91bmNlciIsIlJvb3QiLCJjYWxsYmFja3MiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwidXNlTGF5b3V0RWZmZWN0IiwiX19ORVhUX1RFU1RfTU9ERSIsInVzZUVmZmVjdCIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nvar _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nvar _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nvar _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// Temporary workaround for the issue described here:\n// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123\n// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import\n// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries\n// eslint-disable-next-line no-unused-expressions\nPromise.resolve().then(function() {\n    return _interopRequireWildcard(__webpack_require__(/*! ./dev/noop */ \"./node_modules/next/dist/client/dev/noop.js\"));\n});\n;\nvar assetPrefix = window.__NEXT_DATA__.assetPrefix;\nvar prefix = assetPrefix || '';\nvar webpackHMR = (0, _webpackHotMiddlewareClient).default();\n(0, _websocket).connectHMR({\n    path: \"\".concat(prefix, \"/_next/webpack-hmr\")\n});\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter,\n    render: _.render,\n    renderError: _.renderError\n};\n(0, _).initNext({\n    webpackHMR: webpackHMR\n}).then(function(param) {\n    var renderCtx = param.renderCtx;\n    var devPagesManifestListener = function devPagesManifestListener(event) {\n        if (event.data.indexOf('devPagesManifest') !== -1) {\n            fetch(\"\".concat(prefix, \"/_next/static/development/_devPagesManifest.json\")).then(function(res) {\n                return res.json();\n            }).then(function(manifest) {\n                window.__DEV_PAGES_MANIFEST = manifest;\n            }).catch(function(err) {\n                console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n        } else if (event.data.indexOf('middlewareChanges') !== -1) {\n            return window.location.reload();\n        } else if (event.data.indexOf('serverOnlyChanges') !== -1) {\n            var pages = JSON.parse(event.data).pages;\n            // Make sure to reload when the dev-overlay is showing for an\n            // API route\n            if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                return window.location.reload();\n            }\n            if (!_.router.clc && pages.includes(_.router.pathname)) {\n                console.log('Refreshing page data due to server-side change');\n                buildIndicatorHandler('building');\n                var clearIndicator = function() {\n                    return buildIndicatorHandler('built');\n                };\n                _.router.replace(_.router.pathname + '?' + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(_.router.query), new URLSearchParams(location.search))), _.router.asPath).finally(clearIndicator);\n            }\n        }\n    };\n    (0, _onDemandEntriesClient).default();\n    var buildIndicatorHandler = function() {\n    };\n    (0, _websocket).addMessageListener(devPagesManifestListener);\n    if (true) {\n        (0, _devBuildWatcher).default(function(handler) {\n            buildIndicatorHandler = handler;\n        });\n    }\n    // delay rendering until after styles have been applied in development\n    (0, _fouc).displayContent(function() {\n        (0, _).render(renderCtx);\n    });\n}).catch(function(err) {\n    console.error('Error was not caught', err);\n}); //# sourceMappingURL=next-dev.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaLEdBQUcsQ0FBQ0EsQ0FBQyxHQUFHQyxtQkFBTyxDQUFDLG9EQUFJO0FBQ3BCLEdBQUcsQ0FBQ0Msc0JBQXNCLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVHQUFnQztBQUM1RixHQUFHLENBQUNHLDJCQUEyQixHQUFHRCxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyxpSEFBcUM7QUFDdEcsR0FBRyxDQUFDSSxnQkFBZ0IsR0FBR0Ysc0JBQXNCLENBQUNGLG1CQUFPLENBQUMseUZBQXlCO0FBQy9FLEdBQUcsQ0FBQ0ssS0FBSyxHQUFHTCxtQkFBTyxDQUFDLCtEQUFZO0FBQ2hDLEdBQUcsQ0FBQ00sVUFBVSxHQUFHTixtQkFBTyxDQUFDLHFHQUErQjtBQUN4RCxHQUFHLENBQUNPLFlBQVksR0FBR1AsbUJBQU8sQ0FBQyxvSEFBd0M7U0FDMURFLHNCQUFzQixDQUFDTSxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDRSxPQUFPLEVBQUVGLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUFxRDtBQUNyRCxFQUF1RTtBQUN2RSxFQUFxRztBQUNyRyxFQUE2RztBQUM3RyxFQUFpRDs7dURBQzFDLCtEQUFZOzs7QUFDbkIsR0FBSyxDQUFvQkcsV0FBVyxHQUFXQyxNQUFNLENBQTdDQyxhQUFhLENBQUlGLFdBQVc7QUFDcEMsR0FBSyxDQUFDRyxNQUFNLEdBQUdILFdBQVcsSUFBSSxDQUFFO0FBQ2hDLEdBQUssQ0FBQ0ksVUFBVSxJQUFJLENBQUMsRUFBRVosMkJBQTJCLEVBQUVPLE9BQU87Q0FDMUQsQ0FBQyxFQUFFSixVQUFVLEVBQUVVLFVBQVUsQ0FBQyxDQUFDO0lBQ3hCQyxJ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SyxHQUFHLEdBQUcsQ0FBQ1UsZUFBZSxDQUFDaEIsUUFBUSxDQUFDaUIsTUFBTSxLQUFLMUQsQ0FBQyxDQUFDcUIsTUFBTSxDQUFDc0MsTUFBTSxFQUFFQyxPQUFPLENBQUNSLGNBQWM7WUFDeE4sQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0tBNUJBLENBQUMsRUFBRWxELHNCQUFzQixFQUFFUyxPQUFPO0lBQ25DLEdBQUcsQ0FBQ3dDLHFCQUFxQixHQUFHLFFBQzlCLEdBRGtDLENBQUM7SUFDakMsQ0FBQztLQTJCQSxDQUFDLEVBQUU1QyxVQUFVLEVBQUVzRCxrQkFBa0IsQ0FBQ2pDLHdCQUF3QjtJQUMzRCxFQUFFLEVBQUVrQyxJQUFrQyxFQUFFLENBQUM7U0FDcEMsQ0FBQyxFQUFFekQsZ0JBQWdCLEVBQUVNLE9BQU8sQ0FBQyxRQUFRLENBQVBzRCxPQUFPLEVBQUcsQ0FBQztZQUN0Q2QscUJBQXFCLEdBQUdjLE9BQU87UUFDbkMsQ0FBQztJQUNMLENBQUM7SUFDRCxFQUFzRTtLQUNyRSxDQUFDLEVBQUUzRCxLQUFLLEVBQUU0RCxjQUFjLENBQUMsUUFDNUIsR0FEZ0MsQ0FBQztTQUMxQixDQUFDLEVBQUVsRSxDQUFDLEVBQUV1QixNQUFNLENBQUNJLFNBQVM7SUFDM0IsQ0FBQztBQUNMLENBQUMsRUFBRVUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7SUFDYkMsT0FBTyxDQUFDNEIsS0FBSyxDQUFDLENBQXNCLHVCQUFFN0IsR0FBRztBQUM3QyxDQUFDLEVBRUQsQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbmV4dC1kZXYuanM/MzUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfID0gcmVxdWlyZShcIi4vXCIpO1xudmFyIF9vbkRlbWFuZEVudHJpZXNDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO1xudmFyIF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50XCIpKTtcbnZhciBfZGV2QnVpbGRXYXRjaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvZGV2LWJ1aWxkLXdhdGNoZXJcIikpO1xudmFyIF9mb3VjID0gcmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG4vLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgdGhlIGlzc3VlIGRlc2NyaWJlZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzc1I2lzc3VlY29tbWVudC00MDc0MzgxMjNcbi8vIFRoZSBydW50aW1lQ2h1bmsgZG9lc24ndCBoYXZlIGR5bmFtaWMgaW1wb3J0IGhhbmRsaW5nIGNvZGUgd2hlbiB0aGVyZSBoYXNuJ3QgYmVlbiBhIGR5bmFtaWMgaW1wb3J0XG4vLyBUaGUgcnVudGltZUNodW5rIGNhbid0IGhvdCByZWxvYWQgaXRzZWxmIGN1cnJlbnRseSB0byBjb3JyZWN0IGl0IHdoZW4gYWRkaW5nIHBhZ2VzIHVzaW5nIG9uLWRlbWFuZC1lbnRyaWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5pbXBvcnQoJy4vZGV2L25vb3AnKTs7XG5jb25zdCB7IF9fTkVYVF9EQVRBX186IHsgYXNzZXRQcmVmaXggIH0gLCAgfSA9IHdpbmRvdztcbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnO1xuY29uc3Qgd2VicGFja0hNUiA9ICgwLCBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQpLmRlZmF1bHQoKTtcbigwLCBfd2Vic29ja2V0KS5jb25uZWN0SE1SKHtcbiAgICBwYXRoOiBgJHtwcmVmaXh9L19uZXh0L3dlYnBhY2staG1yYFxufSk7XG53aW5kb3cubmV4dCA9IHtcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgLy8gcm91dGVyIGlzIGluaXRpYWxpemVkIGxhdGVyIHNvIGl0IGhhcyB0byBiZSBsaXZlLWJpbmRlZFxuICAgIGdldCByb3V0ZXIgKCkge1xuICAgICAgICByZXR1cm4gXy5yb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBfLmVtaXR0ZXIsXG4gICAgcmVuZGVyOiBfLnJlbmRlcixcbiAgICByZW5kZXJFcnJvcjogXy5yZW5kZXJFcnJvclxufTtcbigwLCBfKS5pbml0TmV4dCh7XG4gICAgd2VicGFja0hNUlxufSkudGhlbigoeyByZW5kZXJDdHggIH0pPT57XG4gICAgKDAsIF9vbkRlbWFuZEVudHJpZXNDbGllbnQpLmRlZmF1bHQoKTtcbiAgICBsZXQgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gKCk9PntcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdkZXZQYWdlc01hbmlmZXN0JykgIT09IC0xKSB7XG4gICAgICAgICAgICBmZXRjaChgJHtwcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKVxuICAgICAgICAgICAgKS50aGVuKChtYW5pZmVzdCk9PntcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBkZXZQYWdlc01hbmlmZXN0YCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignbWlkZGxld2FyZUNoYW5nZXMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdzZXJ2ZXJPbmx5Q2hhbmdlcycpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlcyAgfSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVsb2FkIHdoZW4gdGhlIGRldi1vdmVybGF5IGlzIHNob3dpbmcgZm9yIGFuXG4gICAgICAgICAgICAvLyBBUEkgcm91dGVcbiAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhfLnJvdXRlci5xdWVyeS5fX05FWFRfUEFHRSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLnJvdXRlci5jbGMgJiYgcGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgcGFnZSBkYXRhIGR1ZSB0byBzZXJ2ZXItc2lkZSBjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIoJ2J1aWxkaW5nJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYXJJbmRpY2F0b3IgPSAoKT0+YnVpbGRJbmRpY2F0b3JIYW5kbGVyKCdidWlsdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIF8ucm91dGVyLnJlcGxhY2UoXy5yb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXy5yb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgXy5yb3V0ZXIuYXNQYXRoKS5maW5hbGx5KGNsZWFySW5kaWNhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcik7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpIHtcbiAgICAgICAgKDAsIF9kZXZCdWlsZFdhdGNoZXIpLmRlZmF1bHQoKGhhbmRsZXIpPT57XG4gICAgICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZGVsYXkgcmVuZGVyaW5nIHVudGlsIGFmdGVyIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZCBpbiBkZXZlbG9wbWVudFxuICAgICgwLCBfZm91YykuZGlzcGxheUNvbnRlbnQoKCk9PntcbiAgICAgICAgKDAsIF8pLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH0pO1xufSkuY2F0Y2goKGVycik9PntcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsIGVycik7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX29uRGVtYW5kRW50cmllc0NsaWVudCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQiLCJfZGV2QnVpbGRXYXRjaGVyIiwiX2ZvdWMiLCJfd2Vic29ja2V0IiwiX3F1ZXJ5c3RyaW5nIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJhc3NldFByZWZpeCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJ3ZWJwYWNrSE1SIiwiY29ubmVjdEhNUiIsInBhdGgiLCJuZXh0IiwidmVyc2lvbiIsInJvdXRlciIsImVtaXR0ZXIiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsImluaXROZXh0IiwidGhlbiIsInJlbmRlckN0eCIsImRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsImluZGV4T2YiLCJmZXRjaCIsInJlcyIsImpzb24iLCJtYW5pZmVzdCIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwiY2F0Y2giLCJlcnIiLCJjb25zb2xlIiwibG9nIiwibG9jYXRpb24iLCJyZWxvYWQiLCJwYWdlcyIsIkpTT04iLCJwYXJzZSIsImluY2x1ZGVzIiwicXVlcnkiLCJfX05FWFRfUEFHRSIsImNsYyIsInBhdGhuYW1lIiwiYnVpbGRJbmRpY2F0b3JIYW5kbGVyIiwiY2xlYXJJbmRpY2F0b3IiLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImFzUGF0aCIsImZpbmFsbHkiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0JVSUxEX0lORElDQVRPUiIsImhhbmRsZXIiLCJkaXNwbGF5Q29udGVudCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _isError = _interopRequireDefault1(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js?678a\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js?3e74\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nvar _resolveRewrites = _interopRequireDefault1(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar detectDomainLocale;\nif (false) {}\nvar basePath =  false || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    var pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var detectedDomain; } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    var queryIndex = path.indexOf('?');\n    var hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = \"/\".concat(path);\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils).getLocationOrigin();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = '';\n    var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || '';\n        var _param = dynamicGroups[param], repeat = _param.repeat, optional = _param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    var filteredQuery = {\n    };\n    Object.keys(query).forEach(function(key) {\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        var interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            var ref = interpolateAs(finalUrl.pathname, finalUrl.pathname, query), result = ref.result, params = ref.params;\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var ref = _slicedToArray(resolveHref(router, url, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefHadOrigin = resolvedHref.startsWith(origin);\n    var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then(function(res) {\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then(function(data) {\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(\"Failed to load static props\");\n                });\n            }\n            throw new Error(\"Failed to load static props\");\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text: text\n    }).catch(function(err) {\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then(function(data) {\n        if (!persistCache || 'development' !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch(function(err) {\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname2, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = function(e) {\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, idx = state.idx;\n            if (false) { var v; }\n            _this._idx = idx;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === _this.asPath && pathname1 === _this.pathname) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname2);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname2 !== '/_error') {\n            var ref;\n            this.components[this.route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        this.pathname = pathname2;\n        this.query = query1;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname2) && self.__NEXT_DATA__.autoExport;\n        this.asPath = autoExportDynamic ? pathname2 : as1;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isFallback = isFallback;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = false;\n        if (false) {}\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as1.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options1 = {\n                    locale: locale\n                };\n                options1._shouldResolveHref = as1 !== pathname2;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname2),\n                    query: query1\n                }), (0, _utils).getURL(), options1);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('pushState', url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('replaceState', url, as, options);\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var shouldResolveHref, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, shallow, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, resolvedAs, rewritesResult, effect, route, parsedAs1, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref, ref1, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll, shouldScroll, resetScroll;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (isLocalURL(url)) {\n                                    _ctx.next = 3;\n                                    break;\n                                }\n                                window.location.href = url;\n                                return _ctx.abrupt(\"return\", false);\n                            case 3:\n                                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                if (options._h) {\n                                    this.isReady = true;\n                                }\n                                prevLocale = this.locale;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n                                if (typeof options.locale === 'undefined') {\n                                    options.locale = this.locale;\n                                }\n                                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                                if (localePathResult.detectedLocale) {\n                                    this.locale = localePathResult.detectedLocale;\n                                    parsedAs.pathname = addBasePath(parsedAs.pathname);\n                                    as = (0, _utils).formatWithValidation(parsedAs);\n                                    url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n                                }\n                                didNavigate = false;\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale);\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                if (!didNavigate) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 18:\n                                if (!options._h) {\n                                    this.isSsr = false;\n                                }\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark('routeChange');\n                                }\n                                var ref8, ref2;\n                                ref8 = options, ref2 = ref8.shallow, shallow = ref2 === void 0 ? false : ref2, ref8;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (this._inFlightRoute) {\n                                    this.abortComponentLoad(this._inFlightRoute, routeProps);\n                                }\n                                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n                                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n                                this._inFlightRoute = as;\n                                localeChange = prevLocale !== this.locale;\n                                if (!(!options._h && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                                    _ctx.next = 35;\n                                    break;\n                                }\n                                this.asPath = cleanedAs;\n                                Router.events.emit('hashChangeStart', as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                this.changeState(method, url, as, options);\n                                this.scrollToHash(cleanedAs);\n                                this.notify(this.components[this.route], null);\n                                Router.events.emit('hashChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 35:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                var ref3;\n                                ref3 = parsed, pathname = ref3.pathname, query = ref3.query, ref3;\n                                ;\n                                _ctx.prev = 38;\n                                _ctx.next = 41;\n                                return Promise.all([\n                                    this.pageLoader.getPageList(),\n                                    (0, _routeLoader).getClientBuildManifest(),\n                                    this.pageLoader.getMiddlewareList(), \n                                ]);\n                            case 41:\n                                var ref4, ref5;\n                                ref4 = _ctx.sent, pages = ref4[0], ref5 = ref4[1], rewrites = ref5.__rewrites, ref5, ref4;\n                                _ctx.next = 48;\n                                break;\n                            case 44:\n                                _ctx.prev = 44;\n                                _ctx.t0 = _ctx[\"catch\"](38);\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 48:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = 'replaceState';\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n                                if (shouldResolveHref && pathname !== '/_error') {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = addBasePath(pathname);\n                                            url = (0, _utils).formatWithValidation(parsed);\n                                        }\n                                    }\n                                }\n                                if (isLocalURL(as)) {\n                                    _ctx.next = 57;\n                                    break;\n                                }\n                                if (false) {}\n                                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                            case 55:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 57:\n                                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n                                _ctx.next = 60;\n                                return this._preflightRequest({\n                                    as: as,\n                                    cache: 'development' === 'production',\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 60:\n                                effect = _ctx.sent;\n                                if (!(effect.type === 'rewrite')) {\n                                    _ctx.next = 65;\n                                    break;\n                                }\n                                {\n                                    query = _objectSpread({\n                                    }, query, effect.parsedAs.query);\n                                    resolvedAs = effect.asPath;\n                                    pathname = effect.resolvedHref;\n                                    parsed.pathname = effect.resolvedHref;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 77;\n                                break;\n                            case 65:\n                                if (!(effect.type === 'redirect' && effect.newAs)) {\n                                    _ctx.next = 69;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", this.change(method, effect.newUrl, effect.newAs, options));\n                            case 69:\n                                if (!(effect.type === 'redirect' && effect.destination)) {\n                                    _ctx.next = 74;\n                                    break;\n                                }\n                                window.location.href = effect.destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 74:\n                                if (!(effect.type === 'refresh')) {\n                                    _ctx.next = 77;\n                                    break;\n                                }\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 77:\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                                    _ctx.next = 93;\n                                    break;\n                                }\n                                parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                asPathname = parsedAs1.pathname;\n                                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                shouldInterpolate = route === asPathname;\n                                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n                                };\n                                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                                    _ctx.next = 92;\n                                    break;\n                                }\n                                missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                    return !query[param];\n                                });\n                                if (!(missingParams.length > 0)) {\n                                    _ctx.next = 90;\n                                    break;\n                                }\n                                if (true) {\n                                    console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                                }\n                                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n                            case 90:\n                                _ctx.next = 93;\n                                break;\n                            case 92:\n                                if (shouldInterpolate) {\n                                    as = (0, _utils).formatWithValidation(Object.assign({\n                                    }, parsedAs1, {\n                                        pathname: interpolatedAs.result,\n                                        query: omitParmsFromQuery(query, interpolatedAs.params)\n                                    }));\n                                } else {\n                                    // Merge params into `query`, overwriting any specified in search\n                                    Object.assign(query, routeMatch);\n                                }\n                            case 93:\n                                Router.events.emit('routeChangeStart', as, routeProps);\n                                _ctx.prev = 94;\n                                ;\n                                _ctx.next = 98;\n                                return this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n                            case 98:\n                                routeInfo = _ctx.sent;\n                                var ref6;\n                                ref6 = routeInfo, error = ref6.error, props = ref6.props, __N_SSG = ref6.__N_SSG, __N_SSP = ref6.__N_SSP, ref6;\n                                if (!((__N_SSG || __N_SSP) && props)) {\n                                    _ctx.next = 125;\n                                    break;\n                                }\n                                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                                    _ctx.next = 110;\n                                    break;\n                                }\n                                destination = props.pageProps.__N_REDIRECT;\n                                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                                    _ctx.next = 108;\n                                    break;\n                                }\n                                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                var ref7;\n                                ref7 = prepareUrlAs(this, destination, destination), newUrl = ref7.url, newAs = ref7.as, ref7;\n                                return _ctx.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n                            case 108:\n                                window.location.href = destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {\n                                }));\n                            case 110:\n                                this.isPreview = !!props.__N_PREVIEW;\n                                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                                    _ctx.next = 125;\n                                    break;\n                                }\n                                ;\n                                _ctx.prev = 113;\n                                _ctx.next = 116;\n                                return this.fetchComponent('/404');\n                            case 116:\n                                notFoundRoute = '/404';\n                                _ctx.next = 122;\n                                break;\n                            case 119:\n                                _ctx.prev = 119;\n                                _ctx.t1 = _ctx[\"catch\"](113);\n                                notFoundRoute = '/_error';\n                            case 122:\n                                _ctx.next = 124;\n                                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                                    shallow: false\n                                });\n                            case 124:\n                                routeInfo = _ctx.sent;\n                            case 125:\n                                Router.events.emit('beforeHistoryChange', as, routeProps);\n                                this.changeState(method, url, as, options);\n                                if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && this.route === route;\n                                ;\n                                shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                _ctx.next = 134;\n                                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(function(e) {\n                                    if (e.cancelled) error = error || e;\n                                    else throw e;\n                                });\n                            case 134:\n                                if (!error) {\n                                    _ctx.next = 137;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                                throw error;\n                            case 137:\n                                if (false) {}\n                                Router.events.emit('routeChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 142:\n                                _ctx.prev = 142;\n                                _ctx.t2 = _ctx[\"catch\"](94);\n                                if (!((0, _isError).default(_ctx.t2) && _ctx.t2.cancelled)) {\n                                    _ctx.next = 146;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", false);\n                            case 146:\n                                throw _ctx.t2;\n                            case 147:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            38,\n                            44\n                        ],\n                        [\n                            94,\n                            142\n                        ],\n                        [\n                            113,\n                            119\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, param) {\n                var options = param === void 0 ? {\n                } : param;\n                if (true) {\n                    if (typeof window.history === 'undefined') {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === 'undefined') {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    '', as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var Component, styleSheets, props, routeInfo;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (!err.cancelled) {\n                                    _ctx.next = 2;\n                                    break;\n                                }\n                                // bubble up cancellation errors\n                                throw err;\n                            case 2:\n                                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                                    _ctx.next = 6;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', err, as, routeProps);\n                                // If we can't load the page it could be one of following reasons\n                                //  1. Page doesn't exists\n                                //  2. Page does exist in a different zone\n                                //  3. Internal error while loading the page\n                                // So, doing a hard reload is the proper way to deal with this.\n                                window.location.href = as;\n                                // Changing the URL doesn't block executing the current code path.\n                                // So let's throw a cancellation error stop the routing logic.\n                                throw buildCancellationError();\n                            case 6:\n                                _ctx.prev = 6;\n                                ;\n                                ;\n                                ;\n                                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                                    _ctx.next = 14;\n                                    break;\n                                }\n                                _ctx.next = 13;\n                                return this.fetchComponent('/_error');\n                            case 13:\n                                var ref;\n                                ref = _ctx.sent, Component = ref.page, styleSheets = ref.styleSheets, ref;\n                            case 14:\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (routeInfo.props) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                _ctx.prev = 16;\n                                _ctx.next = 19;\n                                return this.getInitialProps(Component, {\n                                    err: err,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 19:\n                                routeInfo.props = _ctx.sent;\n                                _ctx.next = 26;\n                                break;\n                            case 22:\n                                _ctx.prev = 22;\n                                _ctx.t0 = _ctx[\"catch\"](16);\n                                console.error('Error in error page `getInitialProps`: ', _ctx.t0);\n                                routeInfo.props = {\n                                };\n                            case 26:\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 29:\n                                _ctx.prev = 29;\n                                _ctx.t1 = _ctx[\"catch\"](6);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps, true));\n                            case 32:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            6,\n                            29\n                        ],\n                        [\n                            16,\n                            22\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, __N_RSC, isValidElementType, dataHref, props, _this1, fresh, data;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.prev = 0;\n                                _this = this;\n                                existingRouteInfo = this.components[route];\n                                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {\n                                    _ctx.next = 5;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", existingRouteInfo);\n                            case 5:\n                                cachedRouteInfo = undefined;\n                                // can only use non-initial route info\n                                // cannot reuse route info in development since it can change after HMR\n                                if (false) {}\n                                _ctx.t0 = cachedRouteInfo;\n                                if (_ctx.t0) {\n                                    _ctx.next = 12;\n                                    break;\n                                }\n                                _ctx.next = 11;\n                                return this.fetchComponent(route).then(function(res) {\n                                    return {\n                                        Component: res.page,\n                                        styleSheets: res.styleSheets,\n                                        __N_SSG: res.mod.__N_SSG,\n                                        __N_SSP: res.mod.__N_SSP,\n                                        __N_RSC: !!res.page.__next_rsc__\n                                    };\n                                });\n                            case 11:\n                                _ctx.t0 = _ctx.sent;\n                            case 12:\n                                routeInfo = _ctx.t0;\n                                var ref;\n                                ref = routeInfo, Component = ref.Component, __N_SSG = ref.__N_SSG, __N_SSP = ref.__N_SSP, __N_RSC = ref.__N_RSC, ref;\n                                if (false) {}\n                                isValidElementType = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\").isValidElementType;\n                                if (isValidElementType(Component)) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n                            case 18:\n                                ;\n                                if (__N_SSG || __N_SSP || __N_RSC) {\n                                    dataHref = this.pageLoader.getDataHref({\n                                        href: (0, _utils).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        asPath: resolvedAs,\n                                        ssg: __N_SSG,\n                                        rsc: __N_RSC,\n                                        locale: this.locale\n                                    });\n                                }\n                                _ctx.next = 22;\n                                return this._getData(function() {\n                                    return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this.isSsr, false, __N_SSG ? _this.sdc : _this.sdr, !!__N_SSG) : _this.getInitialProps(Component, {\n                                        pathname: pathname,\n                                        query: query,\n                                        asPath: as,\n                                        locale: _this.locale,\n                                        locales: _this.locales,\n                                        defaultLocale: _this.defaultLocale\n                                    });\n                                });\n                            case 22:\n                                props = _ctx.sent;\n                                if (!__N_RSC) {\n                                    _ctx.next = 29;\n                                    break;\n                                }\n                                _this1 = this;\n                                _ctx.next = 27;\n                                return this._getData(function() {\n                                    return _this1._getFlightData(dataHref);\n                                });\n                            case 27:\n                                var ref1;\n                                ref1 = _ctx.sent, fresh = ref1.fresh, data = ref1.data, ref1;\n                                props.pageProps = Object.assign(props.pageProps, {\n                                    __flight_serialized__: data,\n                                    __flight_fresh__: fresh\n                                });\n                            case 29:\n                                routeInfo.props = props;\n                                this.components[route] = routeInfo;\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 34:\n                                _ctx.prev = 34;\n                                _ctx.t1 = _ctx[\"catch\"](0);\n                                return _ctx.abrupt(\"return\", this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps));\n                            case 37:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            34\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(route, pathname, query, as, data, resetScroll) {\n                this.isFallback = false;\n                this.route = route;\n                this.pathname = pathname;\n                this.query = query;\n                this.asPath = as;\n                return this.notify(data, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var ref = _slicedToArray(this.asPath.split('#'), 2), oldUrlNoHash = ref[0], oldHash = ref[1];\n                var ref9 = _slicedToArray(as.split('#'), 2), newUrlNoHash = ref9[0], newHash = ref9[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var ref = _slicedToArray(as.split('#'), 2), hash = ref[1];\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === '' || hash === 'top') {\n                    window.scrollTo(0, 0);\n                    return;\n                }\n                // First we check if the element by id is found\n                var idEl = document.getElementById(hash);\n                if (idEl) {\n                    idEl.scrollIntoView();\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(hash)[0];\n                if (nameEl) {\n                    nameEl.scrollIntoView();\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, param, param1) {\n                var asPath = param === void 0 ? url : param, options = param1 === void 0 ? {\n                } : param1;\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, rewrites, rewritesResult, effects, route;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _this = this;\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                var ref;\n                                ref = parsed, pathname = ref.pathname, query = ref.query, ref;\n                                if (false) {}\n                                _ctx.next = 6;\n                                return this.pageLoader.getPageList();\n                            case 6:\n                                pages = _ctx.sent;\n                                resolvedAs = asPath;\n                                if (true) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                ;\n                                _ctx.next = 12;\n                                return (0, _routeLoader).getClientBuildManifest();\n                            case 12:\n                                var ref10;\n                                ref10 = _ctx.sent, rewrites = ref10.__rewrites, ref10;\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, this.locales);\n                                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 19;\n                                break;\n                            case 18:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = pathname;\n                                        url = (0, _utils).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 19:\n                                if (false) {}\n                                return _ctx.abrupt(\"return\");\n                            case 21:\n                                _ctx.next = 23;\n                                return this._preflightRequest({\n                                    as: asPath,\n                                    cache: true,\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 23:\n                                effects = _ctx.sent;\n                                if (effects.type === 'rewrite') {\n                                    parsed.pathname = effects.resolvedHref;\n                                    pathname = effects.resolvedHref;\n                                    query = _objectSpread({\n                                    }, query, effects.parsedAs.query);\n                                    resolvedAs = effects.asPath;\n                                    url = (0, _utils).formatWithValidation(parsed);\n                                }\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                _ctx.next = 28;\n                                return Promise.all([\n                                    this.pageLoader._isSsg(route).then(function(isSsg) {\n                                        return isSsg ? fetchNextData(_this.pageLoader.getDataHref({\n                                            href: url,\n                                            asPath: resolvedAs,\n                                            ssg: true,\n                                            locale: typeof options.locale !== 'undefined' ? options.locale : _this.locale\n                                        }), false, false, _this.sdc, true) : false;\n                                    }),\n                                    this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n                                ]);\n                            case 28:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var _this, cancelled, cancel, handleCancelled, componentResult;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _this = this;\n                                cancelled = false;\n                                cancel = this.clc = function() {\n                                    cancelled = true;\n                                };\n                                handleCancelled = function() {\n                                    if (cancelled) {\n                                        var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                                        error.cancelled = true;\n                                        throw error;\n                                    }\n                                    if (cancel === _this.clc) {\n                                        _this.clc = null;\n                                    }\n                                };\n                                _ctx.prev = 4;\n                                _ctx.next = 7;\n                                return this.pageLoader.loadPage(route);\n                            case 7:\n                                componentResult = _ctx.sent;\n                                handleCancelled();\n                                return _ctx.abrupt(\"return\", componentResult);\n                            case 12:\n                                _ctx.prev = 12;\n                                _ctx.t0 = _ctx[\"catch\"](4);\n                                handleCancelled();\n                                throw _ctx.t0;\n                            case 16:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this, [\n                        [\n                            4,\n                            12\n                        ]\n                    ]);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error('Loading initial props cancelled');\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                var _this = this;\n                var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n                if (!this.isPreview && this.sdc[cacheKey]) {\n                    return Promise.resolve({\n                        fresh: false,\n                        data: this.sdc[cacheKey]\n                    });\n                }\n                return fetchNextData(dataHref, true, true, this.sdc, false).then(function(serialized) {\n                    _this.sdc[cacheKey] = serialized;\n                    return {\n                        fresh: true,\n                        data: serialized\n                    };\n                });\n            }\n        },\n        {\n            key: \"_preflightRequest\",\n            value: function _preflightRequest(options) {\n                return _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee() {\n                    var ref, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, newUrl, newAs;\n                    return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                ;\n                                cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n                                _ctx.next = 4;\n                                return this.pageLoader.getMiddlewareList();\n                            case 4:\n                                fns = _ctx.sent;\n                                requiresPreflight = fns.some(function(param) {\n                                    var _param = _slicedToArray(param, 2), middleware = _param[0], isSSR = _param[1];\n                                    return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n                                });\n                                if (requiresPreflight) {\n                                    _ctx.next = 8;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 8:\n                                _ctx.next = 10;\n                                return this._getPreflightData({\n                                    preflightHref: options.as,\n                                    shouldCache: options.cache\n                                });\n                            case 10:\n                                preflight = _ctx.sent;\n                                if (!((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/'))) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n                                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n                                ;\n                                ;\n                                if (options.pages.includes(fsPathname)) {\n                                    matchedPage = true;\n                                    resolvedHref = fsPathname;\n                                } else {\n                                    resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                                    if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                                        matchedPage = true;\n                                    }\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'rewrite',\n                                    asPath: parsed.pathname,\n                                    parsedAs: parsed,\n                                    matchedPage: matchedPage,\n                                    resolvedHref: resolvedHref\n                                });\n                            case 18:\n                                if (!preflight.redirect) {\n                                    _ctx.next = 24;\n                                    break;\n                                }\n                                if (!preflight.redirect.startsWith('/')) {\n                                    _ctx.next = 23;\n                                    break;\n                                }\n                                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                                var ref11;\n                                ref11 = prepareUrlAs(this, cleanRedirect, cleanRedirect), newUrl = ref11.url, newAs = ref11.as, ref11;\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    newUrl: newUrl,\n                                    newAs: newAs\n                                });\n                            case 23:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: preflight.redirect\n                                });\n                            case 24:\n                                if (!(preflight.refresh && !preflight.ssr)) {\n                                    _ctx.next = 26;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'refresh'\n                                });\n                            case 26:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 27:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, this);\n                }).bind(this))();\n            }\n        },\n        {\n            key: \"_getPreflightData\",\n            value: function _getPreflightData(params) {\n                var _this = this, _this2 = this;\n                var preflightHref = params.preflightHref, _shouldCache = params.shouldCache, shouldCache = _shouldCache === void 0 ? false : _shouldCache;\n                var ref = new URL(preflightHref, window.location.href), cacheKey = ref.href;\n                if (false) {}\n                return fetch(preflightHref, {\n                    method: 'HEAD',\n                    credentials: 'same-origin',\n                    headers: {\n                        'x-middleware-preflight': '1'\n                    }\n                }).then(function(res) {\n                    if (!res.ok) {\n                        throw new Error(\"Failed to preflight request\");\n                    }\n                    return {\n                        redirect: res.headers.get('Location'),\n                        refresh: res.headers.has('x-middleware-refresh'),\n                        rewrite: res.headers.get('x-middleware-rewrite'),\n                        ssr: !!res.headers.get('x-middleware-ssr')\n                    };\n                }).then(function(data) {\n                    if (shouldCache) {\n                        _this.sde[cacheKey] = data;\n                    }\n                    return data;\n                }).catch(function(err) {\n                    delete _this2.sde[cacheKey];\n                    throw err;\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var ref = this.components['/_app'], App = ref.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"abortComponentLoad\",\n            value: function abortComponentLoad(as, routeProps) {\n                if (this.clc) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n                    this.clc();\n                    this.clc = null;\n                }\n            }\n        },\n        {\n            key: \"notify\",\n            value: function notify(data, resetScroll) {\n                return this.sub(data, this.components['/_app'].Component, resetScroll);\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRSxlQUFlO0FBQ3pDRixpQkFBaUIsR0FBR0csU0FBUztBQUM3QkgsaUJBQWlCLEdBQUdJLFNBQVM7QUFDN0JKLG1CQUFtQixHQUFHSyxXQUFXO0FBQ2pDTCxtQkFBbUIsR0FBR00sV0FBVztBQUNqQ04sbUJBQW1CLEdBQUdPLFdBQVc7QUFDakNQLGtCQUFrQixHQUFHUSxVQUFVO0FBQy9CUixxQkFBcUIsR0FBR1MsYUFBYTtBQUNyQ1QsbUJBQW1CLEdBQUdVLFdBQVc7QUFDakNWLGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDWSx1QkFBdUIsR0FBR0MsbUJBQU8sQ0FBQyw2R0FBMEM7QUFDaEYsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMscUZBQThCO0FBQ3pELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHQyx1QkFBc0IsQ0FBQ0gsbUJBQU8sQ0FBQyx1RUFBdUI7QUFDckUsR0FBRyxDQUFDSSxvQkFBb0IsR0FBR0osbUJBQU8sQ0FBQyw0R0FBdUM7QUFDMUUsR0FBRyxDQUFDSyxvQkFBb0IsR0FBR0wsbUJBQU8sQ0FBQyw2R0FBK0I7QUFDbEUsR0FBRyxDQUFDTSxLQUFLLEdBQUdILHVCQUFzQixDQUFDSCxtQkFBTyxDQUFDLDREQUFTO0FBQ3BELEdBQUcsQ0FBQ08sTUFBTSxHQUFHUCxtQkFBTyxDQUFDLDhEQUFVO0FBQy9CLEdBQUcsQ0FBQ1EsVUFBVSxHQUFH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aXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXREb21haW5Mb2NhbGUgPSBnZXREb21haW5Mb2NhbGU7XG5leHBvcnRzLmFkZExvY2FsZSA9IGFkZExvY2FsZTtcbmV4cG9ydHMuZGVsTG9jYWxlID0gZGVsTG9jYWxlO1xuZXhwb3J0cy5oYXNCYXNlUGF0aCA9IGhhc0Jhc2VQYXRoO1xuZXhwb3J0cy5hZGRCYXNlUGF0aCA9IGFkZEJhc2VQYXRoO1xuZXhwb3J0cy5kZWxCYXNlUGF0aCA9IGRlbEJhc2VQYXRoO1xuZXhwb3J0cy5pc0xvY2FsVVJMID0gaXNMb2NhbFVSTDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcyA9IGludGVycG9sYXRlQXM7XG5leHBvcnRzLnJlc29sdmVIcmVmID0gcmVzb2x2ZUhyZWY7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbnZhciBfcm91dGVMb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL21pdHRcIikpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfaXNEeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcGFyc2VSZWxhdGl2ZVVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcmVzb2x2ZVJld3JpdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLXJld3JpdGVzXCIpKTtcbnZhciBfcm91dGVNYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbnZhciBfcm91dGVSZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xudmFyIF9nZXRNaWRkbGV3YXJlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbWlkZGxld2FyZS1yZWdleFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmxldCBkZXRlY3REb21haW5Mb2NhbGU7XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKS5kZXRlY3REb21haW5Mb2NhbGU7XG59XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGgsIHByZWZpeCkge1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykgfHwgIXByZWZpeCkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goYCR7cHJlZml4fSR7cGF0aG5hbWV9YCkgKyBwYXRoLnN1YnN0cihwYXRobmFtZS5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGxvY2FsZSA9IGxvY2FsZSB8fCAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKTtcbiAgICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke2Jhc2VQYXRoIHx8ICcnfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRMb2NhbGUocGF0aCwgbG9jYWxlLCBkZWZhdWx0TG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAhcGF0aExvd2VyLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlTG93ZXIgKyAnLycpICYmIHBhdGhMb3dlciAhPT0gJy8nICsgbG9jYWxlTG93ZXIgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSkgOiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGRlbExvY2FsZShwYXRoLCBsb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb2NhbGUgJiYgKHBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSB8fCBwYXRoTG93ZXIgPT09ICcvJyArIGxvY2FsZUxvd2VyKSA/IChwYXRobmFtZS5sZW5ndGggPT09IGxvY2FsZS5sZW5ndGggKyAxID8gJy8nIDogJycpICsgcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpIDogcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aCkge1xuICAgIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgICBpZiAocXVlcnlJbmRleCA+IC0xIHx8IGhhc2hJbmRleCA+IC0xKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKTtcbn1cbmZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGgpIHtcbiAgICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICAgIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKTtcbn1cbmZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpO1xuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmwpIHtcbiAgICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykgfHwgdXJsLnN0YXJ0c1dpdGgoJyMnKSB8fCB1cmwuc3RhcnRzV2l0aCgnPycpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkge1xuICAgIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8IC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeTtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpO1xuICAgIGlmICghcGFyYW1zLmV2ZXJ5KChwYXJhbSk9PntcbiAgICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnO1xuICAgICAgICBjb25zdCB7IHJlcGVhdCAsIG9wdGlvbmFsICB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV07XG4gICAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWA7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJiAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID0gaW50ZXJwb2xhdGVkUm91dGUucmVwbGFjZShyZXBsYWNlZCwgcmVwZWF0ID8gdmFsdWUubWFwKC8vIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgZnVsbHkgZW5jb2RlZCBpbnN0ZWFkIG9mIGp1c3RcbiAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuICAgICAgICAvLyBpbnRvIHRoZSBVUkwgYW5kIHdlIGV4cGVjdCBVUkwgZW5jb2RlZCBzZWdtZW50c1xuICAgICAgICAvLyB3aGVuIHBhcnNpbmcgZHluYW1pYyByb3V0ZSBwYXJhbXNcbiAgICAgICAgKHNlZ21lbnQpPT5lbmNvZGVVUklDb21wb25lbnQoc2VnbWVudClcbiAgICAgICAgKS5qb2luKCcvJykgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCAnLycpO1xuICAgIH0pKSB7XG4gICAgICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcbiAgICAgICAgO1xuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZmlsdGVyZWRRdWVyeSA9IHtcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRRdWVyeTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVIcmVmKHJvdXRlciwgaHJlZiwgcmVzb2x2ZUFzKSB7XG4gICAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgICBsZXQgYmFzZTtcbiAgICBsZXQgdXJsQXNTdHJpbmcgPSB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZik7XG4gICAgLy8gcmVwZWF0ZWQgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMgaW4gdGhlIFVSTCBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGludmFsaWQgYW5kIHdpbGwgbmV2ZXIgbWF0Y2ggYSBOZXh0LmpzIHBhZ2UvZmlsZVxuICAgIGNvbnN0IHVybFByb3RvTWF0Y2ggPSB1cmxBc1N0cmluZy5tYXRjaCgvXlthLXpBLVpdezEsfTpcXC9cXC8vKTtcbiAgICBjb25zdCB1cmxBc1N0cmluZ05vUHJvdG8gPSB1cmxQcm90b01hdGNoID8gdXJsQXNTdHJpbmcuc3Vic3RyKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KCc/Jyk7XG4gICAgaWYgKCh1cmxQYXJ0c1swXSB8fCAnJykubWF0Y2goLyhcXC9cXC98XFxcXCkvKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIG5leHQvcm91dGVyOiAke3VybEFzU3RyaW5nfSwgcmVwZWF0ZWQgZm9yd2FyZC1zbGFzaGVzICgvLykgb3IgYmFja3NsYXNoZXMgXFxcXCBhcmUgbm90IHZhbGlkIGluIHRoZSBocmVmYCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSAoMCwgX3V0aWxzKS5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsQXNTdHJpbmdOb1Byb3RvKTtcbiAgICAgICAgdXJsQXNTdHJpbmcgPSAodXJsUHJvdG9NYXRjaCA/IHVybFByb3RvTWF0Y2hbMF0gOiAnJykgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcbiAgICAgICAgICAgIHVybEFzU3RyaW5nXG4gICAgICAgIF0gOiB1cmxBc1N0cmluZztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwodXJsQXNTdHJpbmcuc3RhcnRzV2l0aCgnIycpID8gcm91dGVyLmFzUGF0aCA6IHJvdXRlci5wYXRobmFtZSwgJ2h0dHA6Ly9uJyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTCgnLycsICdodHRwOi8vbicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpO1xuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goZmluYWxVcmwucGF0aG5hbWUpO1xuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJztcbiAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nKS5zZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCAsIHBhcmFtcyAgfSA9IGludGVycG9sYXRlQXMoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKSA6IGZpbmFsVXJsLmhyZWY7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcbiAgICB9IGNhdGNoIChfMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgY29uc3QgaHJlZkhhZE9yaWdpbiA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFnZSkgJiYgKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge1xuICAgIH1cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdHMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgfSkudGhlbigocmVzKT0+e1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzLnRleHQgPyByZXMudGV4dCgpIDogcmVzLmpzb24oKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyLCB0ZXh0LCBpbmZsaWdodENhY2hlLCBwZXJzaXN0Q2FjaGUpIHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICB0ZXh0XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AuXG4gICAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLm1hcmtBc3NldEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMgLCBwYWdlTG9hZGVyICwgQXBwICwgd3JhcEFwcCAsIENvbXBvbmVudCAsIGVyciAsIHN1YnNjcmlwdGlvbiAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZGVmYXVsdExvY2FsZSAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgIH0pe1xuICAgICAgICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICAgICAgICB0aGlzLnNkYyA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW4tZmxpZ2h0IFNlcnZlciBEYXRhIFJlcXVlc3RzLCBmb3IgZGVkdXBpbmdcbiAgICAgICAgdGhpcy5zZHIgPSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluLWZsaWdodCBtaWRkbGV3YXJlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgICAgICB0aGlzLnNkZSA9IHtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faWR4ID0gMDtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBhcyAsIG9wdGlvbnMgLCBpZHggIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pZHggPSBpZHg7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09IHRoaXMuYXNQYXRoICYmIHBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgdGhpcy5yb3V0ZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgICAgICAgICAgICBfX05fUlNDOiAhISgocmVmID0gQ29tcG9uZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5fX25leHRfcnNjX18pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcbiAgICAgICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXM7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2s7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIWlzUHJldmlldztcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISFkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsb2FkKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovIGJhY2soKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucyA9IHtcbiAgICB9KSB7XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRSZXNvbHZlSHJlZiA9IG9wdGlvbnMuX2ggfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgcGF0aE5vUXVlcnlIYXNoKHVybCkgPT09IHBhdGhOb1F1ZXJ5SGFzaChhcyk7XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuX2gpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkxvY2FsZSA9IHRoaXMubG9jYWxlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmxvY2FsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSB0aGlzLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSBhZGRCYXNlUGF0aCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgodXJsKSA/IGRlbEJhc2VQYXRoKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAoISgocmVmID0gdGhpcy5sb2NhbGVzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5pbmNsdWRlcyh0aGlzLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIHRoaXMuaXNMb2NhbGVEb21haW4gJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IGRlbEJhc2VQYXRoKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7ZGV0ZWN0ZWREb21haW4uZG9tYWlufSR7YWRkQmFzZVBhdGgoYCR7dGhpcy5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHt0aGlzLmxvY2FsZX1gfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJyl9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcywgdGhpcy5sb2NhbGUpO1xuICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgIGxldCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSB0aGlzLmxvY2FsZTtcbiAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgIGlmICghb3B0aW9ucy5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSwgbnVsbCk7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlTGlzdCgpLCBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSkgOiBwYXRobmFtZTtcbiAgICAgICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGNsZWFuZWRBcywgdGhpcy5sb2NhbGUpKSwgcGFnZXMsIHJld3JpdGVzLCBxdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKVxuICAgICAgICAgICAgICAgICwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGF3YWl0IHRoaXMuX3ByZWZsaWdodFJlcXVlc3Qoe1xuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICBjYWNoZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBlZmZlY3QuYXNQYXRoO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBlZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0Lm5ld0FzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBlZmZlY3QubmV3VXJsLCBlZmZlY3QubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGVmZmVjdC50eXBlID09PSAncmVkaXJlY3QnICYmIGVmZmVjdC5kZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlZmZlY3QuZGVzdGluYXRpb247XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9PntcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVmZmVjdC50eXBlID09PSAncmVmcmVzaCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9PntcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtzaG91bGRJbnRlcnBvbGF0ZSA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX3V0aWxzKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgbGV0IHsgZXJyb3IgLCBwcm9wcyAsIF9fTl9TU0cgLCBfX05fU1NQICB9ID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucGFnZVByb3BzICYmIHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8obm90Rm91bmRSb3V0ZSwgbm90Rm91bmRSb3V0ZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5faCAmJiBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYxID0gcmVmLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGU7XG4gICAgICAgICAgICB2YXIgX3Njcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9PSBudWxsICYmIF9zY3JvbGwgIT09IHZvaWQgMCA/IF9zY3JvbGwgOiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBjbGVhbmVkQXMsIHJvdXRlSW5mbywgZm9yY2VkU2Nyb2xsICE9PSBudWxsICYmIGZvcmNlZFNjcm9sbCAhPT0gdm9pZCAwID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGwpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycjEpICYmIGVycjEuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCAoMCwgX3V0aWxzKS5nZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAgaWR4OiB0aGlzLl9pZHggPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5faWR4IDogdGhpcy5faWR4ICsgMVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3JvdXRlTG9hZGVyKS5pc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgQ29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlU2hlZXRzO1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzdHlsZVNoZWV0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAoeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGNhbiBvbmx5IHVzZSBub24taW5pdGlhbCByb3V0ZSBpbmZvXG4gICAgICAgICAgICAvLyBjYW5ub3QgcmV1c2Ugcm91dGUgaW5mbyBpbiBkZXZlbG9wbWVudCBzaW5jZSBpdCBjYW4gY2hhbmdlIGFmdGVyIEhNUlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGV4aXN0aW5nUm91dGVJbmZvICYmICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nUm91dGVJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgICAgICAgICAgICBfX05fUlNDOiAhIXJlcy5wYWdlLl9fbmV4dF9yc2NfX1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgeyBDb21wb25lbnQgLCBfX05fU1NHICwgX19OX1NTUCAsIF9fTl9SU0MgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YUhyZWY7XG4gICAgICAgICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQIHx8IF9fTl9SU0MpIHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgc3NnOiBfX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICByc2M6IF9fTl9SU0MsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YSgoKT0+X19OX1NTRyB8fCBfX05fU1NQID8gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzciwgZmFsc2UsIF9fTl9TU0cgPyB0aGlzLnNkYyA6IHRoaXMuc2RyLCAhIV9fTl9TU0cpIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKF9fTl9SU0MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyZXNoICwgZGF0YSAgfSA9IGF3YWl0IHRoaXMuX2dldERhdGEoKCk9PnRoaXMuX2dldEZsaWdodERhdGEoZGF0YUhyZWYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHByb3BzLnBhZ2VQcm9wcywge1xuICAgICAgICAgICAgICAgICAgICBfX2ZsaWdodF9zZXJpYWxpemVkX186IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIF9fZmxpZ2h0X2ZyZXNoX186IGZyZXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpID8gZXJyIDogbmV3IEVycm9yKGVyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5hc1BhdGggPSBhcztcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGggPSB1cmwsIG9wdGlvbnMgPSB7XG4gICAgfSkge1xuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXNQYXRoLCB0aGlzLmxvY2FsZSkpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKVxuICAgICAgICAgICAgLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfdXRpbHMpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBhd2FpdCB0aGlzLl9wcmVmbGlnaHRSZXF1ZXN0KHtcbiAgICAgICAgICAgIGFzOiBhc1BhdGgsXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVmZmVjdHMudHlwZSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBlZmZlY3RzLnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZWZmZWN0cy5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAuLi5lZmZlY3RzLnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGVmZmVjdHMuYXNQYXRoO1xuICAgICAgICAgICAgdXJsID0gKDAsIF91dGlscykuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBzc2c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9jYWxlIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgICB9KSwgZmFsc2UsIGZhbHNlLCB0aGlzLnNkYywgdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLCBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gdGhpcy5jbGMgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiB0aGlzLnNkY1tjYWNoZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGZyZXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNkY1tjYWNoZUtleV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0cnVlLCB0cnVlLCB0aGlzLnNkYywgZmFsc2UpLnRoZW4oKHNlcmlhbGl6ZWQpPT57XG4gICAgICAgICAgICB0aGlzLnNkY1tjYWNoZUtleV0gPSBzZXJpYWxpemVkO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcmVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBzZXJpYWxpemVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3ByZWZsaWdodFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoaGFzQmFzZVBhdGgob3B0aW9ucy5hcykgPyBkZWxCYXNlUGF0aChvcHRpb25zLmFzKSA6IG9wdGlvbnMuYXMsIHRoaXMubG9jYWxlKTtcbiAgICAgICAgY29uc3QgZm5zID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmVMaXN0KCk7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVzUHJlZmxpZ2h0ID0gZm5zLnNvbWUoKFttaWRkbGV3YXJlLCBpc1NTUl0pPT57XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX2dldE1pZGRsZXdhcmVSZWdleCkuZ2V0TWlkZGxld2FyZVJlZ2V4KG1pZGRsZXdhcmUsICFpc1NTUikpKGNsZWFuZWRBcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlcXVpcmVzUHJlZmxpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmbGlnaHQgPSBhd2FpdCB0aGlzLl9nZXRQcmVmbGlnaHREYXRhKHtcbiAgICAgICAgICAgIHByZWZsaWdodEhyZWY6IG9wdGlvbnMuYXMsXG4gICAgICAgICAgICBzaG91bGRDYWNoZTogb3B0aW9ucy5jYWNoZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKChyZWYgPSBwcmVmbGlnaHQucmV3cml0ZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHByZWZsaWdodC5yZXdyaXRlKSA/IGRlbEJhc2VQYXRoKHByZWZsaWdodC5yZXdyaXRlKSA6IHByZWZsaWdodC5yZXdyaXRlLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGZzUGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhcnNlZC5wYXRobmFtZSk7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlZFBhZ2U7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkUGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmID0gZnNQYXRobmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBvcHRpb25zLnBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRIcmVmICE9PSBwYXJzZWQucGF0aG5hbWUgJiYgb3B0aW9ucy5wYWdlcy5pbmNsdWRlcyhyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRQYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IHBhcnNlZC5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICBwYXJzZWRBczogcGFyc2VkLFxuICAgICAgICAgICAgICAgIG1hdGNoZWRQYWdlLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmxpZ2h0LnJlZGlyZWN0KSB7XG4gICAgICAgICAgICBpZiAocHJlZmxpZ2h0LnJlZGlyZWN0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuUmVkaXJlY3QgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aChwcmVmbGlnaHQucmVkaXJlY3QpID8gZGVsQmFzZVBhdGgocHJlZmxpZ2h0LnJlZGlyZWN0KSA6IHByZWZsaWdodC5yZWRpcmVjdCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBjbGVhblJlZGlyZWN0LCBjbGVhblJlZGlyZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVkaXJlY3QnLFxuICAgICAgICAgICAgICAgICAgICBuZXdVcmwsXG4gICAgICAgICAgICAgICAgICAgIG5ld0FzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogcHJlZmxpZ2h0LnJlZGlyZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBTU1IgcmVxdWVzdHMsIHRoZXkgd2lsbCBiZSBoYW5kbGVkIGxpa2Ugbm9ybWFsIHBhZ2VzLlxuICAgICAgICBpZiAocHJlZmxpZ2h0LnJlZnJlc2ggJiYgIXByZWZsaWdodC5zc3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZnJlc2gnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldFByZWZsaWdodERhdGEocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZmxpZ2h0SHJlZiAsIHNob3VsZENhY2hlID1mYWxzZSAgfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSAgfSA9IG5ldyBVUkwocHJlZmxpZ2h0SHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAhdGhpcy5pc1ByZXZpZXcgJiYgc2hvdWxkQ2FjaGUgJiYgdGhpcy5zZGVbY2FjaGVLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RlW2NhY2hlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoKHByZWZsaWdodEhyZWYsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ3gtbWlkZGxld2FyZS1wcmVmbGlnaHQnOiAnMSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVmbGlnaHQgcmVxdWVzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogcmVzLmhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpLFxuICAgICAgICAgICAgICAgIHJlZnJlc2g6IHJlcy5oZWFkZXJzLmhhcygneC1taWRkbGV3YXJlLXJlZnJlc2gnKSxcbiAgICAgICAgICAgICAgICByZXdyaXRlOiByZXMuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1yZXdyaXRlJyksXG4gICAgICAgICAgICAgICAgc3NyOiAhIXJlcy5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXNzcicpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZGVbY2FjaGVLZXldID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRDb21wb25lbnRMb2FkKGFzLCByb3V0ZVByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldERvbWFpbkxvY2FsZSIsImFkZExvY2FsZSIsImRlbExvY2FsZSIsImhhc0Jhc2VQYXRoIiwiYWRkQmFzZVBhdGgiLCJkZWxCYXNlUGF0aCIsImlzTG9jYWxVUkwiLCJpbnRlcnBvbGF0ZUFzIiwicmVzb2x2ZUhyZWYiLCJkZWZhdWx0IiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIiwiX3JvdXRlTG9hZGVyIiwiX2lzRXJyb3IiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2Rlbm9ybWFsaXplUGFnZVBhdGgiLCJfbm9ybWFsaXplTG9jYWxlUGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzRHluYW1pYyIsIl9wYXJzZVJlbGF0aXZlVXJsIiwiX3F1ZXJ5c3RyaW5nIiwiX3Jlc29sdmVSZXdyaXRlcyIsIl9yb3V0ZU1hdGNoZXIiLCJfcm91dGVSZWdleCIsIl9nZXRNaWRkbGV3YXJlUmVnZXgiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJiYXNlUGF0aCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInBhdGhOb1F1ZXJ5SGFzaCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwic3Vic3RyIiwibGVuZ3RoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0ZWRMb2NhbGUiLCJkZXRlY3RlZERvbWFpbiIsInVuZGVmaW5lZCIsImh0dHAiLCJkb21haW4iLCJkZWZhdWx0TG9jYWxlIiwicGF0aExvd2VyIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVMb3dlciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwiaGFzaEluZGV4Iiwic3Vic3RyaW5nIiwic2xpY2UiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJfIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInJlcGVhdCIsIm9wdGlvbmFsIiwicmVwbGFjZWQiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwibWFwIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJyZXN1bHQiLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJmaWx0ZXJlZFF1ZXJ5IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsIm5vcm1hbGl6ZWRVcmwiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJhc1BhdGgiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwiaGFzaCIsInJlc29sdmVkSHJlZiIsIl8xIiwic3RyaXBPcmlnaW4iLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkQXMiLCJocmVmSGFkT3JpZ2luIiwiYXNIYWRPcmlnaW4iLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwic29tZSIsInBhZ2UiLCJyZSIsInRlc3QiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwib3B0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwicmVzIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZGF0YSIsIm5vdEZvdW5kIiwidGV4dCIsImZldGNoTmV4dERhdGEiLCJkYXRhSHJlZiIsImlzU2VydmVyUmVuZGVyIiwiaW5mbGlnaHRDYWNoZSIsInBlcnNpc3RDYWNoZSIsImxvY2F0aW9uIiwiY2FjaGVLZXkiLCJjYXRjaCIsImVyciIsIm1hcmtBc3NldEVycm9yIiwiUm91dGVyIiwiaW5pdGlhbFByb3BzIiwicGFnZUxvYWRlciIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiaXNQcmV2aWV3Iiwic2RjIiwic2RyIiwic2RlIiwiX2lkeCIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImdldFVSTCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsIm9wdGlvbnMiLCJpZHgiLCJKU09OIiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJwYXJzZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJpc1NzciIsIl9icHMiLCJjaGFuZ2UiLCJzaGFsbG93IiwiX3NoYWxsb3ciLCJjb21wb25lbnRzIiwicmVmIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJfX05fUlNDIiwiX19uZXh0X3JzY19fIiwic3R5bGVTaGVldHMiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0Iiwic3ViIiwiY2xjIiwiX3dyYXBBcHAiLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJpc0xvY2FsZURvbWFpbiIsImhvc3RuYW1lIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwicmVsb2FkIiwiYmFjayIsInB1c2giLCJtZXRob2QiLCJzaG91bGRSZXNvbHZlSHJlZiIsInByZXZMb2NhbGUiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsImFzTm9CYXNlUGF0aCIsInJvdXRlUHJvcHMiLCJjbGVhbmVkQXMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWQiLCJyZXdyaXRlcyIsInJld3JpdGVzUmVzdWx0IiwiZWZmZWN0Iiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJyZWYxIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwibmV3VXJsIiwibmV3QXMiLCJub3RGb3VuZFJvdXRlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsIl9oIiwiUHJvbWlzZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiX2luRmxpZ2h0Um91dGUiLCJhYm9ydENvbXBvbmVudExvYWQiLCJvbmx5QUhhc2hDaGFuZ2UiLCJlbWl0Iiwic2Nyb2xsVG9IYXNoIiwibm90aWZ5IiwiYWxsIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZUxpc3QiLCJfX3Jld3JpdGVzIiwidXJsSXNOZXciLCJwIiwibWF0Y2hlZFBhZ2UiLCJfcHJlZmxpZ2h0UmVxdWVzdCIsImNhY2hlIiwidHlwZSIsImZpbHRlciIsIndhcm4iLCJnZXRSb3V0ZUluZm8iLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsInN0YXR1c0NvZGUiLCJzY3JvbGwiLCJzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJleGlzdGluZ1JvdXRlSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsImZyZXNoIiwibW9kIiwiZ2V0RGF0YUhyZWYiLCJzc2ciLCJyc2MiLCJfZ2V0RGF0YSIsIl9nZXRGbGlnaHREYXRhIiwiX19mbGlnaHRfc2VyaWFsaXplZF9fIiwiX19mbGlnaHRfZnJlc2hfXyIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsInNjcm9sbFRvIiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsInByZWZldGNoIiwiZWZmZWN0cyIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJjYW5jZWwiLCJoYW5kbGVDYW5jZWxsZWQiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwicmVzb2x2ZSIsInNlcmlhbGl6ZWQiLCJmbnMiLCJyZXF1aXJlc1ByZWZsaWdodCIsInByZWZsaWdodCIsImZzUGF0aG5hbWUiLCJjbGVhblJlZGlyZWN0IiwibWlkZGxld2FyZSIsImlzU1NSIiwiZ2V0TWlkZGxld2FyZVJlZ2V4IiwiX2dldFByZWZsaWdodERhdGEiLCJwcmVmbGlnaHRIcmVmIiwic2hvdWxkQ2FjaGUiLCJyZXdyaXRlIiwicmVkaXJlY3QiLCJyZWZyZXNoIiwic3NyIiwiaGVhZGVycyIsImdldCIsImhhcyIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatUrl = formatUrl;\nvar querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\"));\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    var auth = urlObj.auth, hostname = urlObj.hostname;\n    var protocol = urlObj.protocol || '';\n    var pathname = urlObj.pathname || '';\n    var hash = urlObj.hash || '';\n    var query = urlObj.query || '';\n    var host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\".concat(hostname, \"]\") : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(querystring.urlQueryToSearchParams(query));\n    }\n    var search = urlObj.search || query && \"?\".concat(query) || '';\n    if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanM/NTk2My5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHRSxTQUFTO0FBQzdCLEdBQUcsQ0FBQ0MsV0FBVyxHQUFHQyx1QkFBdUIsQ0FBQ0MsbUJBQU8sQ0FBQywyRkFBZTtTQUN4REQsdUJBQXVCLENBQUNFLEdBQUcsRUFBRSxDQUFDO0lBQ25DLEVBQUUsRUFBRUEsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsRUFBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQ0QsR0FBRztJQUNkLENBQUMsTUFBTSxDQUFDO1FBQ0osR0FBRyxDQUFDRSxNQUFNLEdBQUcsQ0FBQztRQUNkLENBQUM7UUFDRCxFQUFFLEVBQUVGLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNkLEdBQUcsQ0FBQyxHQUFHLENBQUNHLEdBQUcsSUFBSUgsR0FBRyxDQUFDLENBQUM7Z0JBQ2hCLEVBQUUsRUFBRVIsTUFBTSxDQUFDWSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTixHQUFHLEVBQUVHLEdBQUcsR0FBRyxDQUFDO29CQUNqRCxHQUFHLENBQUNJLElBQUksR0FBR2YsTUFBTSxDQUFDQyxjQUFjLElBQUlELE1BQU0sQ0FBQ2dCLHdCQUF3QixHQUFHaEIsTUFBTSxDQUFDZ0Isd0JBQXdCLENBQUNSLEdBQUcsRUFBRUcsR0FBRyxJQUFJLENBQUM7b0JBQ25ILENBQUM7b0JBQ0QsRUFBRSxFQUFFSSxJQUFJLENBQUNFLEdBQUcsSUFBSUYsSUFBSSxDQUFDRyxHQUFHLEVBQUUsQ0FBQzt3QkFDdkJsQixNQUFNLENBQUNDLGNBQWMsQ0FBQ1MsTUFBTSxFQUFFQyxHQUFHLEVBQUVJLElBQUk7b0JBQzNDLENBQUMsTUFBTSxDQUFDO3dCQUNKTCxNQUFNLENB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a0I7SUFDdkRNLE1BQU0sR0FBR0EsTUFBTSxDQUFDTCxPQUFPLENBQUMsQ0FBRyxJQUFFLENBQUs7SUFDbEMsTUFBTSxDQUFFLEdBQWFGLE1BQUksQ0FBZkosUUFBUSxFQUFVQyxNQUFRLENBQWZHLElBQUksRUFBY08sTUFBTSxDQUFqQlYsUUFBUSxFQUFZQyxNQUFJLENBQWJTLE1BQU0sRUFBUSxPQUFMVCxJQUFJO0FBQ3hELENBQUMsQ0FFcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvcm1hdFVybCA9IGZvcm1hdFVybDtcbnZhciBxdWVyeXN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge1xuICAgICAgICB9O1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cbn1cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87XG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqKSB7XG4gICAgbGV0IHsgYXV0aCAsIGhvc3RuYW1lICB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJztcbiAgICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJztcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJyc7XG4gICAgbGV0IGhvc3QgPSBmYWxzZTtcbiAgICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnO1xuICAgIGlmICh1cmxPYmouaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0O1xuICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICAgICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgYD8ke3F1ZXJ5fWAgfHwgJyc7XG4gICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuICAgIGlmICh1cmxPYmouc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSAnJztcbiAgICB9XG4gICAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtdXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZvcm1hdFVybCIsInF1ZXJ5c3RyaW5nIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsIm5ld09iaiIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJkZWZhdWx0Iiwic2xhc2hlZFByb3RvY29scyIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsInN1YnN0ciIsInNsYXNoZXMiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?cdbb\");\nfunction parseRelativeUrl(url, base) {\n    var globalBase = new URL( false ? 0 : (0, _utils).getLocationOrigin());\n    var resolvedBase = base ? new URL(base, globalBase) : globalBase;\n    var ref = new URL(url, resolvedBase), pathname = ref.pathname, searchParams = ref.searchParams, search = ref.search, hash = ref.hash, href = ref.href, origin = ref.origin;\n    if (origin !== globalBase.origin) {\n        throw new Error(\"invariant: invalid relative URL, router received \".concat(url));\n    }\n    return {\n        pathname: pathname,\n        query: (0, _querystring).searchParamsToUrlQuery(searchParams),\n        search: search,\n        hash: hash,\n        href: href.slice(globalBase.origin.length)\n    };\n} //# sourceMappingURL=parse-relative-url.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHdCQUF3QixHQUFHRSxnQkFBZ0I7QUFDM0MsR0FBRyxDQUFDQyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsaUVBQWE7QUFDbEMsR0FBRyxDQUFDQyxZQUFZLEdBQUdELG1CQUFPLENBQUMsMkZBQWU7U0FDakNGLGdCQUFnQixDQUFDSSxHQUFHLEVBQUVDLElBQUksRUFBRSxDQUFDO0lBQ2xDLEdBQUssQ0FBQ0MsVUFBVSxHQUFHLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDLE1BQTZCLEdBQUcsQ0FBVSxJQUFJLENBQUMsRUFBRU4sTUFBTSxFQUFFTyxpQkFBaUI7SUFDckcsR0FBSyxDQUFDQyxZQUFZLEdBQUdKLElBQUksR0FBRyxHQUFHLENBQUNFLEdBQUcsQ0FBQ0YsSUFBSSxFQUFFQyxVQUFVLElBQUlBLFVBQVU7SUFDbEUsR0FBSyxDQUFnRSxHQUEwQixHQUExQixHQUFHLENBQUNDLEdBQUcsQ0FBQ0gsR0FBRyxFQUFFSyxZQUFZLEdBQXRGQyxRQUFRLEdBQXFELEdBQTBCLENBQXZGQSxRQUFRLEVBQUdDLFlBQVksR0FBc0MsR0FBMEIsQ0FBNUVBLFlBQVksRUFBR0MsTUFBTSxHQUE2QixHQUEwQixDQUE3REEsTUFBTSxFQUFHQyxJQUFJLEdBQXNCLEdBQTBCLENBQXBEQSxJQUFJLEVBQUdDLElBQUksR0FBZSxHQUEwQixDQUE3Q0EsSUFBSSxFQUFHQyxNQUFNLEdBQU0sR0FBMEIsQ0FBdENBLE1BQU07SUFDL0QsRUFBRSxFQUFFQSxNQUFNLEtBQUtULFVBQVUsQ0FBQ1MsTUFBTSxFQUFFLENBQUM7UUFDL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFFLENBQWlELG1EQUFNLE9BQUpaLEdBQUc7SUFDM0UsQ0FBQztJQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ0pNLFFBQVEsRUFBUkEsUUFBUTtRQUNSTyxLQUFLLEdBQUcsQ0FBQyxFQUFFZCxZQUFZLEVBQUVlLHNCQUFzQixDQUFDUCxZQUFZO1FBQzVEQyxNQUFNLEVBQU5BLE1BQU07UUFDTkMsSUFBSSxFQUFKQSxJQUFJO1FBQ0pDLElBQUksRUFBRUEsSUFBSSxDQUFDSyxLQUFLLENBQUNiLFVBQVUsQ0FBQ1MsTUFBTSxDQUFDSyxNQUFNO0lBQzdDLENBQUM7QUFDTCxDQUFDLENBRTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLmpzPzRlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlUmVsYXRpdmVVcmwgPSBwYXJzZVJlbGF0aXZlVXJsO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi9xdWVyeXN0cmluZ1wiKTtcbmZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsLCBiYXNlKSB7XG4gICAgY29uc3QgZ2xvYmFsQmFzZSA9IG5ldyBVUkwodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogKDAsIF91dGlscykuZ2V0TG9jYXRpb25PcmlnaW4oKSk7XG4gICAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlO1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBzZWFyY2hQYXJhbXMgLCBzZWFyY2ggLCBoYXNoICwgaHJlZiAsIG9yaWdpbiAgfSA9IG5ldyBVUkwodXJsLCByZXNvbHZlZEJhc2UpO1xuICAgIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCwgcm91dGVyIHJlY2VpdmVkICR7dXJsfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnk6ICgwLCBfcXVlcnlzdHJpbmcpLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aClcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1yZWxhdGl2ZS11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGFyc2VSZWxhdGl2ZVVybCIsIl91dGlscyIsInJlcXVpcmUiLCJfcXVlcnlzdHJpbmciLCJ1cmwiLCJiYXNlIiwiZ2xvYmFsQmFzZSIsIlVSTCIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWRCYXNlIiwicGF0aG5hbWUiLCJzZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJoYXNoIiwiaHJlZiIsIm9yaWdpbiIsIkVycm9yIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5Iiwic2xpY2UiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _regeneratorRuntime = _interopRequireDefault(__webpack_require__(/*! regenerator-runtime */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n        for(var i = 0, arr2 = new Array(arr.length); i < arr.length; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    }\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n        }));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.formatWithValidation = formatWithValidation;\nexports.HtmlContext = exports.ST = exports.SP = exports.urlObjectKeys = void 0;\nvar _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js?5963\");\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _toConsumableArray(args));\n        }\n        return result;\n    };\n}\nfunction getLocationOrigin() {\n    var _location = window.location, protocol = _location.protocol, hostname = _location.hostname, port = _location.port;\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(port ? ':' + port : '');\n}\nfunction getURL() {\n    var href = window.location.href;\n    var origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    var urlParts = url.split('?');\n    var urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\".concat(urlParts.slice(1).join('?')) : '');\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _asyncToGenerator(_regeneratorRuntime.default.mark(function _callee(App, ctx) {\n        var ref, message, res, props, message1;\n        return _regeneratorRuntime.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (false) {}\n                    ;\n                    if (!((ref = App.prototype) === null || ref === void 0 ? void 0 : ref.getInitialProps)) {\n                        _ctx.next = 5;\n                        break;\n                    }\n                    message = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.\");\n                    throw new Error(message);\n                case 5:\n                    res = ctx.res || ctx.ctx && ctx.ctx.res;\n                    if (App.getInitialProps) {\n                        _ctx.next = 13;\n                        break;\n                    }\n                    if (!(ctx.ctx && ctx.Component)) {\n                        _ctx.next = 12;\n                        break;\n                    }\n                    _ctx.next = 10;\n                    return loadGetInitialProps(ctx.Component, ctx.ctx);\n                case 10:\n                    _ctx.t0 = _ctx.sent;\n                    return _ctx.abrupt(\"return\", {\n                        pageProps: _ctx.t0\n                    });\n                case 12:\n                    return _ctx.abrupt(\"return\", {\n                    });\n                case 13:\n                    _ctx.next = 15;\n                    return App.getInitialProps(ctx);\n                case 15:\n                    props = _ctx.sent;\n                    if (!(res && isResSent(res))) {\n                        _ctx.next = 18;\n                        break;\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 18:\n                    if (props) {\n                        _ctx.next = 21;\n                        break;\n                    }\n                    message1 = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" should resolve to an object. But found \\\"\").concat(props, \"\\\" instead.\");\n                    throw new Error(message1);\n                case 21:\n                    if (true) {\n                        if (Object.keys(props).length === 0 && !ctx.ctx) {\n                            console.warn(\"\".concat(getDisplayName(App), \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\"));\n                        }\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 23:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nvar urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes', \n];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach(function(key) {\n                if (urlObjectKeys.indexOf(key) === -1) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \".concat(key));\n                }\n            });\n        }\n    }\n    return (0, _formatUrl).formatUrl(url);\n}\nvar SP = typeof performance !== 'undefined';\nexports.SP = SP;\nvar ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';\nexports.ST = ST;\nvar DecodeError = /*#__PURE__*/ function(Error) {\n    _inherits(DecodeError, Error);\n    function DecodeError() {\n        _classCallCheck(this, DecodeError);\n        return _possibleConstructorReturn(this, _getPrototypeOf(DecodeError).apply(this, arguments));\n    }\n    return DecodeError;\n}(_wrapNativeSuper(Error));\nexports.DecodeError = DecodeError;\nvar HtmlContext = (0, _react).createContext(null);\nexports.HtmlContext = HtmlContext;\nif (true) {\n    HtmlContext.displayName = 'HtmlContext';\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0UsUUFBUTtBQUMzQkYseUJBQXlCLEdBQUdHLGlCQUFpQjtBQUM3Q0gsY0FBYyxHQUFHSSxNQUFNO0FBQ3ZCSixzQkFBc0IsR0FBR0ssY0FBYztBQUN2Q0wsaUJBQWlCLEdBQUdNLFNBQVM7QUFDN0JOLGdDQUFnQyxHQUFHTyx3QkFBd0I7QUFDM0RQLDJCQUEyQixHQUFHUSxtQkFBbUI7QUFDakRSLDRCQUE0QixHQUFHUyxvQkFBb0I7QUFDbkRULG1CQUFtQixHQUFHQSxVQUFVLEdBQUdBLFVBQVUsR0FBR0EscUJBQXFCLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDOUUsR0FBRyxDQUFDYyxVQUFVLEdBQUdDLG1CQUFPLENBQUMsc0dBQTJCO0FBQ3BELEdBQUcsQ0FBQ0MsTUFBTSxHQUFHRCxtQkFBTyxDQUFDLDRDQUFPO1NBQ25CYixRQUFRLENBQUNlLEVBQUUsRUFBRSxDQUFDO0lBQ25CLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLEtBQUs7SUFDaEIsR0FBRyxDQUFDQyxNQUFNO0lBQ1YsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDO3lDQUFSQyxJQUFJO1lBQUpBLElBQUk7O1FBQ1gsRUFBRSxHQUFHRixJQUFJLEVBQUUsQ0FBQztZQUNSQSxJQUFJLEdBQUcsSUFBSTtZQUNYQyxNQUFNLEdBQUdGLEVBQUUsQ0FBRkEsS0FBVyxDQUFYQSxJQUFJ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b2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanM/ZTdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXhlY09uY2UgPSBleGVjT25jZTtcbmV4cG9ydHMuZ2V0TG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbjtcbmV4cG9ydHMuZ2V0VVJMID0gZ2V0VVJMO1xuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xuZXhwb3J0cy5pc1Jlc1NlbnQgPSBpc1Jlc1NlbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyA9IG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcztcbmV4cG9ydHMubG9hZEdldEluaXRpYWxQcm9wcyA9IGxvYWRHZXRJbml0aWFsUHJvcHM7XG5leHBvcnRzLmZvcm1hdFdpdGhWYWxpZGF0aW9uID0gZm9ybWF0V2l0aFZhbGlkYXRpb247XG5leHBvcnRzLkh0bWxDb250ZXh0ID0gZXhwb3J0cy5TVCA9IGV4cG9ydHMuU1AgPSBleHBvcnRzLnVybE9iamVjdEtleXMgPSB2b2lkIDA7XG52YXIgX2Zvcm1hdFVybCA9IHJlcXVpcmUoXCIuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIGV4ZWNPbmNlKGZuKSB7XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgaWYgKCF1c2VkKSB7XG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgLCBob3N0bmFtZSAsIHBvcnQgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YDtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKTtcbiAgICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZycgPyBDb21wb25lbnQgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdO1xuICAgIHJldHVybiB1cmxOb1F1ZXJ5Ly8gZmlyc3Qgd2UgcmVwbGFjZSBhbnkgbm9uLWVuY29kZWQgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkXG4gICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC9cXC8rL2csICcvJykgKyAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJyk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSBBcHAucHJvdG90eXBlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKEFwcCl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcbiAgICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtnZXREaXNwbGF5TmFtZShBcHApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgJ2F1dGgnLFxuICAgICdoYXNoJyxcbiAgICAnaG9zdCcsXG4gICAgJ2hvc3RuYW1lJyxcbiAgICAnaHJlZicsXG4gICAgJ3BhdGgnLFxuICAgICdwYXRobmFtZScsXG4gICAgJ3BvcnQnLFxuICAgICdwcm90b2NvbCcsXG4gICAgJ3F1ZXJ5JyxcbiAgICAnc2VhcmNoJyxcbiAgICAnc2xhc2hlcycsIFxuXTtcbmV4cG9ydHMudXJsT2JqZWN0S2V5cyA9IHVybE9iamVjdEtleXM7XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRVcmwodXJsKTtcbn1cbmNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydHMuU1AgPSBTUDtcbmNvbnN0IFNUID0gU1AgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLlNUID0gU1Q7XG5jbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuRGVjb2RlRXJyb3IgPSBEZWNvZGVFcnJvcjtcbmNvbnN0IEh0bWxDb250ZXh0ID0gKDAsIF9yZWFjdCkuY3JlYXRlQ29udGV4dChudWxsKTtcbmV4cG9ydHMuSHRtbENvbnRleHQgPSBIdG1sQ29udGV4dDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgSHRtbENvbnRleHQuZGlzcGxheU5hbWUgPSAnSHRtbENvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjT25jZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiZ2V0RGlzcGxheU5hbWUiLCJpc1Jlc1NlbnQiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJIdG1sQ29udGV4dCIsIlNUIiwiU1AiLCJ1cmxPYmplY3RLZXlzIiwiX2Zvcm1hdFVybCIsInJlcXVpcmUiLCJfcmVhY3QiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsIiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwicmVmIiwibWVzc2FnZSIsInByb3BzIiwicHJvdG90eXBlIiwiZ2V0SW5pdGlhbFByb3BzIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJrZXlzIiwiY29uc29sZSIsIndhcm4iLCJmb3JFYWNoIiwia2V5IiwiaW5kZXhPZiIsImZvcm1hdFVybCIsInBlcmZvcm1hbmNlIiwibWFyayIsIm1lYXN1cmUiLCJEZWNvZGVFcnJvciIsImNyZWF0ZUNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n");

/***/ })

});